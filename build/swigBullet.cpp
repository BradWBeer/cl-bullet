/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGCFFI


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif




#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>



#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>
#include <stdlib.h>


#include <BulletSoftBody/btSoftBody.h>
#include <BulletSoftBody/btSoftBodyHelpers.h>
#include <BulletSoftBody/btSoftRigidDynamicsWorld.h>
#include <BulletSoftBody/btSoftBodyRigidBodyCollisionConfiguration.h>
#include <BulletSoftBody/btDefaultSoftBodySolver.h>
#include <btBulletDynamicsCommon.h>
#include <BulletCollision/CollisionDispatch/btGhostObject.h>



typedef btSoftBody::Element Element;
typedef btSoftBody::Material Material;
typedef btSoftBody::Feature Feature;
typedef btSoftBody::Config Config;
typedef btSoftBody::Node Node;
 typedef btSoftBody::fCollision fCollision;
  typedef btRigidBody::btRigidBodyConstructionInfo btRigidBodyConstructionInfo;
  

EXPORT int _wrap_btGetVersion () {
  int lresult = (int)0 ;
  int result;
  
  try {
    result = (int)btGetVersion();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSqrt (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btSqrt(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFabs (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btFabs(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCos (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btCos(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSin (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btSin(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btTan (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btTan(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAcos (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btAcos(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAsin (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btAsin(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAtan (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btAtan(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAtan2 (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAtan2(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btExp (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btExp(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btLog (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btLog(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btPow (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btPow(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFmod (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btFmod(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAtan2Fast (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAtan2Fast(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btFuzzyZero (btScalar larg1) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)btFuzzyZero(arg1);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btEqual (btScalar larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)btEqual(arg1,arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGreaterEqual (btScalar larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)btGreaterEqual(arg1,arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btIsNegative (btScalar larg1) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)btIsNegative(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btRadians (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btRadians(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btDegrees (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btDegrees(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFsel (btScalar larg1, btScalar larg2, btScalar larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btFsel(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btMachineIsLittleEndian () {
  int lresult = (int)0 ;
  bool result;
  
  try {
    result = (bool)btMachineIsLittleEndian();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT unsigned int _wrap_unsigned_btSelect (unsigned int larg1, unsigned int larg2, unsigned int larg3) {
  unsigned int lresult = (unsigned int)0 ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (unsigned int)btSelect(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT int _wrap_int_btSelect (unsigned int larg1, int larg2, int larg3) {
  int lresult = (int)0 ;
  unsigned int arg1 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)btSelect(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT float _wrap_float_btSelect (unsigned int larg1, float larg2, float larg3) {
  float lresult = (float)0 ;
  unsigned int arg1 ;
  float arg2 ;
  float arg3 ;
  float result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (float)btSelect(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT unsigned int _wrap_unsigned_btSwapEndian_to_unsigned (unsigned int larg1) {
  unsigned int lresult = (unsigned int)0 ;
  unsigned int arg1 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT unsigned short _wrap_unsigned_short_btSwapEndian_to_unsigned_short (unsigned short larg1) {
  unsigned short lresult = (unsigned short)0 ;
  unsigned short arg1 ;
  unsigned short result;
  
  arg1 = larg1;
  try {
    result = (unsigned short)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned short)0;
  }
}


EXPORT unsigned int _wrap_int_btSwapEndian_to_unsigned (int larg1) {
  unsigned int lresult = (unsigned int)0 ;
  int arg1 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT unsigned short _wrap_short_btSwapEndian_to_unsigned_short (short larg1) {
  unsigned short lresult = (unsigned short)0 ;
  short arg1 ;
  unsigned short result;
  
  arg1 = larg1;
  try {
    result = (unsigned short)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned short)0;
  }
}


EXPORT unsigned int _wrap_btSwapEndianFloat (float larg1) {
  unsigned int lresult = (unsigned int)0 ;
  float arg1 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)btSwapEndianFloat(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT float _wrap_btUnswapEndianFloat (unsigned int larg1) {
  float lresult = (float)0 ;
  unsigned int arg1 ;
  float result;
  
  arg1 = larg1;
  try {
    result = (float)btUnswapEndianFloat(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT void _wrap_btSwapEndianDouble (double larg1, unsigned char *larg2) {
  double arg1 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSwapEndianDouble(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT double _wrap_btUnswapEndianDouble (unsigned char *larg1) {
  double lresult = (double)0 ;
  unsigned char *arg1 = (unsigned char *) 0 ;
  double result;
  
  arg1 = larg1;
  try {
    result = (double)btUnswapEndianDouble((unsigned char const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (double)0;
  }
}


EXPORT btScalar _wrap_btLargeDot (btScalar *larg1, btScalar *larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btLargeDot((float const *)arg1,(float const *)arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btNormalizeAngle (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btNormalizeAngle(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btTypedObject *_wrap_new_btTypedObject (int larg1) {
  btTypedObject * lresult = (btTypedObject *)0 ;
  int arg1 ;
  btTypedObject *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTypedObject *)new btTypedObject(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedObject *)0;
  }
}


EXPORT void _wrap_btTypedObject_m_objectType_set (btTypedObject *larg1, int larg2) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_objectType = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTypedObject_m_objectType_get (btTypedObject *larg1) {
  int lresult = (int)0 ;
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_objectType);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTypedObject_getObjectType (btTypedObject *larg1) {
  int lresult = (int)0 ;
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedObject const *)arg1)->getObjectType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_delete_btTypedObject (btTypedObject *larg1) {
  btTypedObject *arg1 = (btTypedObject *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_m_floats_set (btVector3 *larg1, btScalar *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      btScalar *b = (btScalar *) arg1->m_floats;
      for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btVector3_m_floats_get (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *)(btScalar *) ((arg1)->m_floats);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btVector3 *_wrap_new_btVector3_default () {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *result = 0 ;
  
  try {
    result = (btVector3 *)new btVector3();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_new_btVector3 (btScalar *larg1, btScalar *larg2, btScalar *larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btVector3 *)new btVector3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___add_assign__ (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator +=((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___sub_assign__ (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator -=((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___mul_assign__ (btVector3 *larg1, btScalar *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator *=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___div_assign__ (btVector3 *larg1, btScalar *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator /=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btVector3_dot (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->dot((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_length2 (btVector3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector3 const *)arg1)->length2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_btlength (btVector3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector3 const *)arg1)->length();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_norm (btVector3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector3 const *)arg1)->norm();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_distance2 (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->distance2((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_distance (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->distance((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_safeNormalize (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->safeNormalize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_normalize (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->normalize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_normalized (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btVector3 const *)arg1)->normalized();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_rotate (btVector3 *larg1, btVector3 *larg2, btScalar larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btVector3 const *)arg1)->rotate((btVector3 const &)*arg2,arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btVector3_angle (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->angle((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_absolute (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btVector3 const *)arg1)->absolute();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_cross (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btVector3 const *)arg1)->cross((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btVector3_triple (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btVector3 const *)arg1)->triple((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btVector3_minAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->minAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_maxAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->maxAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_furthestAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->furthestAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_closestAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->closestAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector3_setInterpolate3 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btScalar larg4) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setInterpolate3((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btVector3_lerp (btVector3 *larg1, btVector3 *larg2, btScalar *larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btVector3 const *)arg1)->lerp((btVector3 const &)*arg2,(btScalar const &)*arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_mult_equal_btVector3_btVector3 (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator *=((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_getX (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->getX();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_getY (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->getY();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_getZ (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->getZ();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT void _wrap_btVector3_setX (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setX(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setY (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setY(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setZ (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setZ(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setW (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setW(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btVector3_x (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->x();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_y (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->y();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_z (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->z();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_w (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->w();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT int _wrap_btVector3___eq__ (btVector3 *larg1, btVector3 *larg2) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btVector3 const *)arg1)->operator ==((btVector3 const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3___ne__ (btVector3 *larg1, btVector3 *larg2) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btVector3 const *)arg1)->operator !=((btVector3 const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector3_setMax (btVector3 *larg1, btVector3 *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMax((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setMin (btVector3 *larg1, btVector3 *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMin((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setValue (btVector3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_getSkewSymmetricMatrix (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btVector3 const *)arg1)->getSkewSymmetricMatrix(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setZero (btVector3 *larg1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setZero();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btVector3_isZero (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btVector3 const *)arg1)->isZero();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_fuzzyZero (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btVector3 const *)arg1)->fuzzyZero();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector3_serialize (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btVector3 const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_deSerialize (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btVector3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_serializeFloat (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btVector3 const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_deSerializeFloat (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btVector3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_serializeDouble (btVector3 *larg1, btVector3DoubleData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btVector3 const *)arg1)->serializeDouble(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_deSerializeDouble (btVector3 *larg1, btVector3DoubleData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btVector3DoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT long _wrap_btVector3_maxDot (btVector3 *larg1, btVector3 *larg2, long larg3, btScalar *larg4) {
  long lresult = (long)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (long)((btVector3 const *)arg1)->maxDot((btVector3 const *)arg2,arg3,*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (long)0;
  }
}


EXPORT long _wrap_btVector3_minDot (btVector3 *larg1, btVector3 *larg2, long larg3, btScalar *larg4) {
  long lresult = (long)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (long)((btVector3 const *)arg1)->minDot((btVector3 const *)arg2,arg3,*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (long)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_dot3 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = ((btVector3 const *)arg1)->dot3((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_delete_btVector3 (btVector3 *larg1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btDot_btVector3 (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btDot((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btDistance2 (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btDistance2((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btDistance (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btDistance((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngle_from_btVector3s (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAngle((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btCross (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = btCross((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btTriple (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btTriple((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_lerp (btVector3 *larg1, btVector3 *larg2, btScalar *larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = lerp((btVector3 const &)*arg1,(btVector3 const &)*arg2,(float const &)*arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector4 *_wrap_new_btVector4_default () {
  btVector4 * lresult = (btVector4 *)0 ;
  btVector4 *result = 0 ;
  
  try {
    result = (btVector4 *)new btVector4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector4 *)0;
  }
}


EXPORT btVector4 *_wrap_new_btVector4 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btVector4 * lresult = (btVector4 *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btVector4 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btVector4 *)new btVector4((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector4 *)0;
  }
}


EXPORT btVector4 *_wrap_btVector4_absolute4 (btVector4 *larg1) {
  btVector4 * lresult = (btVector4 *)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector4 result;
  
  arg1 = larg1;
  try {
    result = ((btVector4 const *)arg1)->absolute4();
    lresult = new btVector4(result);
    return lresult;
  } catch (...) {
    return (btVector4 *)0;
  }
}


EXPORT btScalar _wrap_btVector4_getW (btVector4 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector4 const *)arg1)->getW();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btVector4_maxAxis4 (btVector4 *larg1) {
  int lresult = (int)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector4 const *)arg1)->maxAxis4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector4_minAxis4 (btVector4 *larg1) {
  int lresult = (int)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector4 const *)arg1)->minAxis4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector4_closestAxis4 (btVector4 *larg1) {
  int lresult = (int)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector4 const *)arg1)->closestAxis4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector4_setValue (btVector4 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btVector4 (btVector4 *larg1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSwapScalarEndian (btScalar *larg1, btScalar *larg2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSwapScalarEndian((float const &)*arg1,*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSwapVector3Endian (btVector3 *larg1, btVector3 *larg2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSwapVector3Endian((btVector3 const &)*arg1,*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUnSwapVector3Endian (btVector3 *larg1) {
  btVector3 *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    btUnSwapVector3Endian(*arg1);
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btQuadWord_getX (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->getX();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_getY (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->getY();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_getZ (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->getZ();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT void _wrap_btQuadWord_setX (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setX(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setY (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setY(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setZ (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setZ(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setW (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setW(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btQuadWord_x (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->x();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_y (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->y();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_z (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->z();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_w (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->w();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT int _wrap_btQuadWord___eq__ (btQuadWord *larg1, btQuadWord *larg2) {
  int lresult = (int)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btQuadWord const *)arg1)->operator ==((btQuadWord const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btQuadWord___ne__ (btQuadWord *larg1, btQuadWord *larg2) {
  int lresult = (int)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btQuadWord const *)arg1)->operator !=((btQuadWord const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btQuadWord_setValue__SWIG_0 (btQuadWord *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setValue__SWIG_1 (btQuadWord *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT btQuadWord *_wrap_new_btQuadWord_default () {
  btQuadWord * lresult = (btQuadWord *)0 ;
  btQuadWord *result = 0 ;
  
  try {
    result = (btQuadWord *)new btQuadWord();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuadWord *)0;
  }
}


EXPORT btQuadWord *_wrap_new_btQuadWord__SWIG_0 (btScalar *larg1, btScalar *larg2, btScalar *larg3) {
  btQuadWord * lresult = (btQuadWord *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuadWord *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuadWord *)0;
  }
}


EXPORT btQuadWord *_wrap_new_btQuadWord__SWIG_1 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuadWord * lresult = (btQuadWord *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuadWord *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuadWord *)0;
  }
}


EXPORT void _wrap_btQuadWord_setMax (btQuadWord *larg1, btQuadWord *larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMax((btQuadWord const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setMin (btQuadWord *larg1, btQuadWord *larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMin((btQuadWord const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btQuadWord (btQuadWord *larg1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion_default () {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *result = 0 ;
  
  try {
    result = (btQuaternion *)new btQuaternion();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion_from_4btScalars (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion_from_btVector_and_btScalar (btVector3 *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btVector3 *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *)new btQuaternion((btVector3 const &)*arg1,(btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion_from_yaw_pitch_and_roll (btScalar *larg1, btScalar *larg2, btScalar *larg3) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT void _wrap_btQuaternion_setRotation (btQuaternion *larg1, btVector3 *larg2, btScalar *larg3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setRotation((btVector3 const &)*arg2,(btScalar const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_setEuler (btQuaternion *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEuler((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_setEulerZYX (btQuaternion *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEulerZYX((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___add_assign__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator +=((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___sub_assign__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator -=((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___mul_assign__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator *=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_mult_equal_btQuaternion_btQuaternion (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator *=((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_dot (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->dot((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_length2 (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->length2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_btlength (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->length();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_normalize (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btQuaternion *) &(arg1)->normalize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___mul__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator *((btScalar const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___div__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator /((btScalar const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___div_assign__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator /=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_normalized (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->normalized();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_angle (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->angle((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_angleShortestPath (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->angleShortestPath((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_getAngle (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->getAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_getAngleShortestPath (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->getAngleShortestPath();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btQuaternion_getAxis (btQuaternion *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->getAxis();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_inverse (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->inverse();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___add__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator +((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___sub__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator -((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___neg__ (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->operator -();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_farthest (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->farthest((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_nearest (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->nearest((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_slerp (btQuaternion *larg1, btQuaternion *larg2, btScalar *larg3) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btQuaternion const *)arg1)->slerp((btQuaternion const &)*arg2,(btScalar const &)*arg3);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_getIdentity () {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *result = 0 ;
  
  try {
    result = (btQuaternion *) &btQuaternion::getIdentity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btScalar *_wrap_btQuaternion_getW (btQuaternion *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuaternion const *)arg1)->getW();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT void _wrap_delete_btQuaternion (btQuaternion *larg1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_dot (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)dot((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btlength (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)length((btQuaternion const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngle_from_btQuaternions (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAngle((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btQuaternion *_wrap_inverse (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = inverse((btQuaternion const &)*arg1);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_slerp (btQuaternion *larg1, btQuaternion *larg2, btScalar *larg3) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = slerp((btQuaternion const &)*arg1,(btQuaternion const &)*arg2,(float const &)*arg3);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btVector3 *_wrap_quatRotate (btQuaternion *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = quatRotate((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_shortestArcQuat (btVector3 *larg1, btVector3 *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = shortestArcQuat((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_shortestArcQuatNormalize2 (btVector3 *larg1, btVector3 *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = shortestArcQuatNormalize2(*arg1,*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform_default () {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *result = 0 ;
  
  try {
    result = (btTransform *)new btTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform_from_btQuaternion_and_btVector (btQuaternion *larg1, btVector3 *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *)new btTransform((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform_from_btQuaternion (btQuaternion *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btQuaternion *arg1 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)new btTransform((btQuaternion const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform_from_btMatrix_and_btVector (btMatrix3x3 *larg1, btVector3 *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform_from_btMatrix (btMatrix3x3 *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform_from_btTransform (btTransform *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)new btTransform((btTransform const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform___assign__ (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *) &(arg1)->operator =((btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btTransform_mult (btTransform *larg1, btTransform *larg2, btTransform *larg3) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->mult((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTransform_btTransform_funcall (btTransform *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator ()((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTransform_mult_btTransform_btVector3 (btTransform *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator *((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btTransform_mult_btTransform_btQuaternion (btTransform *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator *((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btTransform_getBasis (btTransform *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *) &(arg1)->getBasis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btTransform_const_getBasis (btTransform *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *) &((btTransform const *)arg1)->getBasis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTransform_getOrigin (btTransform *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getOrigin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTransform_const_getOrigin (btTransform *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btTransform const *)arg1)->getOrigin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btTransform_getRotation (btTransform *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btTransform const *)arg1)->getRotation();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT void _wrap_btTransform_setFromOpenGLMatrix (btTransform *larg1, btScalar *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFromOpenGLMatrix((btScalar const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_getOpenGLMatrix (btTransform *larg1, btScalar *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTransform const *)arg1)->getOpenGLMatrix(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_setOrigin (btTransform *larg1, btVector3 *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOrigin((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTransform_invXform (btTransform *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->invXform((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTransform_setBasis (btTransform *larg1, btMatrix3x3 *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBasis((btMatrix3x3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_setRotation (btTransform *larg1, btQuaternion *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRotation((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_setIdentity (btTransform *larg1) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setIdentity();
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btTransform___mul_assign__ (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *) &(arg1)->operator *=((btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_inverse (btTransform *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform result;
  
  arg1 = larg1;
  try {
    result = ((btTransform const *)arg1)->inverse();
    lresult = new btTransform(result);
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_inverseTimes (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->inverseTimes((btTransform const &)*arg2);
    lresult = new btTransform(result);
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_mult_btTransform_btTransform (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator *((btTransform const &)*arg2);
    lresult = new btTransform(result);
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_getIdentity () {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *result = 0 ;
  
  try {
    result = (btTransform *) &btTransform::getIdentity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btTransform_serialize (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTransform const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_serializeFloat (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTransform const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_deSerialize (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btTransformFloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_deSerializeDouble (btTransform *larg1, btTransformDoubleData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformDoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btTransformDoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_deSerializeFloat (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btTransformFloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btTransform (btTransform *larg1) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3_default () {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *result = 0 ;
  
  try {
    result = (btMatrix3x3 *)new btMatrix3x3();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3_from_btQuaternion (btQuaternion *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btQuaternion *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *)new btMatrix3x3((btQuaternion const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5, btScalar *larg6, btScalar *larg7, btScalar *larg8, btScalar *larg9) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btMatrix3x3 *)new btMatrix3x3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3_from_btMatrix3x3 (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *)new btMatrix3x3((btMatrix3x3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator =((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3_getColumn (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->getColumn(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3_getRow (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &((btMatrix3x3 const *)arg1)->getRow(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3___aref__ (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator [](arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3_btMatrix3x3_const (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &((btMatrix3x3 const *)arg1)->operator [](arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_mult_equal_btMatrix3x3_btMatrix3x3 (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator *=((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___add_assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator +=((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___sub_assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator -=((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT void _wrap_btMatrix3x3_setFromOpenGLSubMatrix (btMatrix3x3 *larg1, btScalar *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFromOpenGLSubMatrix((btScalar const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setValue (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5, btScalar *larg6, btScalar *larg7, btScalar *larg8, btScalar *larg9, btScalar *larg10) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btScalar *arg10 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9,(btScalar const &)*arg10);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setRotation (btMatrix3x3 *larg1, btQuaternion *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRotation((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setEulerYPR (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEulerYPR((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setEulerZYX (btMatrix3x3 *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEulerZYX(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setIdentity (btMatrix3x3 *larg1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setIdentity();
    
  } catch (...) {
    
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_getIdentity () {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *result = 0 ;
  
  try {
    result = (btMatrix3x3 *) &btMatrix3x3::getIdentity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT void _wrap_btMatrix3x3_getOpenGLSubMatrix (btMatrix3x3 *larg1, btScalar *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->getOpenGLSubMatrix(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getRotation (btMatrix3x3 *larg1, btQuaternion *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->getRotation(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getEulerYPR (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMatrix3x3 const *)arg1)->getEulerYPR(*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getEulerZYX_4 (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, unsigned int larg5) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  unsigned int arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getEulerZYX_3 (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_scaled (btMatrix3x3 *larg1, btVector3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->scaled((btVector3 const &)*arg2);
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_determinant (btMatrix3x3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->determinant();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_adjoint (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->adjoint();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_absolute (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->absolute();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_transpose (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->transpose();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_inverse (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->inverse();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_transposeTimes (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->transposeTimes((btMatrix3x3 const &)*arg2);
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_timesTranspose (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->timesTranspose((btMatrix3x3 const &)*arg2);
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_tdotx (btMatrix3x3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->tdotx((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_tdoty (btMatrix3x3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->tdoty((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_tdotz (btMatrix3x3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->tdotz((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btMatrix3x3_diagonalize (btMatrix3x3 *larg1, btMatrix3x3 *larg2, btScalar larg3, int larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->diagonalize(*arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btMatrix3x3_cofac (btMatrix3x3 *larg1, int larg2, int larg3, int larg4, int larg5) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->cofac(arg2,arg3,arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btMatrix3x3_serialize (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_serializeFloat (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_deSerialize (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btMatrix3x3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_deSerializeFloat (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btMatrix3x3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_deSerializeDouble (btMatrix3x3 *larg1, btMatrix3x3DoubleData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3DoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btMatrix3x3DoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btMatrix3x3 (btMatrix3x3 *larg1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btMotionState (btMotionState *larg1) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMotionState_getWorldTransform (btMotionState *larg1, btTransform *larg2) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMotionState const *)arg1)->getWorldTransform(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMotionState_setWorldTransform (btMotionState *larg1, btTransform *larg2) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultMotionState_m_graphicsWorldTrans_set (btDefaultMotionState *larg1, btTransform *larg2) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_graphicsWorldTrans = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btDefaultMotionState_m_graphicsWorldTrans_get (btDefaultMotionState *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)& ((arg1)->m_graphicsWorldTrans);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btDefaultMotionState_m_centerOfMassOffset_set (btDefaultMotionState *larg1, btTransform *larg2) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_centerOfMassOffset = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btDefaultMotionState_m_centerOfMassOffset_get (btDefaultMotionState *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)& ((arg1)->m_centerOfMassOffset);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btDefaultMotionState_m_startWorldTrans_set (btDefaultMotionState *larg1, btTransform *larg2) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_startWorldTrans = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btDefaultMotionState_m_startWorldTrans_get (btDefaultMotionState *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)& ((arg1)->m_startWorldTrans);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btDefaultMotionState_m_userPointer_set (btDefaultMotionState *larg1, void *larg2) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_userPointer = arg2;
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btDefaultMotionState_m_userPointer_get (btDefaultMotionState *larg1) {
  void * lresult = (void *)0 ;
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *) ((arg1)->m_userPointer);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT btDefaultMotionState *_wrap_new_btDefaultMotionState_default_2 (btTransform *larg1, btTransform *larg2) {
  btDefaultMotionState * lresult = (btDefaultMotionState *)0 ;
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btDefaultMotionState *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btDefaultMotionState *)new btDefaultMotionState((btTransform const &)*arg1,(btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultMotionState *)0;
  }
}


EXPORT btDefaultMotionState *_wrap_new_btDefaultMotionState_default_1 (btTransform *larg1) {
  btDefaultMotionState * lresult = (btDefaultMotionState *)0 ;
  btTransform *arg1 = 0 ;
  btDefaultMotionState *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDefaultMotionState *)new btDefaultMotionState((btTransform const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultMotionState *)0;
  }
}


EXPORT btDefaultMotionState *_wrap_new_btDefaultMotionState_default_0 () {
  btDefaultMotionState * lresult = (btDefaultMotionState *)0 ;
  btDefaultMotionState *result = 0 ;
  
  try {
    result = (btDefaultMotionState *)new btDefaultMotionState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultMotionState *)0;
  }
}


EXPORT void _wrap_btDefaultMotionState_getWorldTransform (btDefaultMotionState *larg1, btTransform *larg2) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btDefaultMotionState const *)arg1)->getWorldTransform(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultMotionState_setWorldTransform (btDefaultMotionState *larg1, btTransform *larg2) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btDefaultMotionState (btDefaultMotionState *larg1) {
  btDefaultMotionState *arg1 = (btDefaultMotionState *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btBroadphaseInterface (btBroadphaseInterface *larg1) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseProxy *_wrap_btBroadphaseInterface_createProxy (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, int larg4, void *larg5, short larg6, short larg7, btDispatcher *larg8, void *larg9) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  short arg6 ;
  short arg7 ;
  btDispatcher *arg8 = (btDispatcher *) 0 ;
  void *arg9 = (void *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btBroadphaseProxy *)(arg1)->createProxy((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btBroadphaseInterface_destroyProxy (btBroadphaseInterface *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->destroyProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_setAabb (btBroadphaseInterface *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4, btDispatcher *larg5) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setAabb(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_getAabb (btBroadphaseInterface *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBroadphaseInterface const *)arg1)->getAabb(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_rayTest__SWIG_0 (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5, btVector3 *larg6) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_rayTest__SWIG_1 (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_rayTest__SWIG_2 (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_aabbTest (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseAabbCallback *larg4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseAabbCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->aabbTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_calculateOverlappingPairs (btBroadphaseInterface *larg1, btDispatcher *larg2) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->calculateOverlappingPairs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btOverlappingPairCache *_wrap_btBroadphaseInterface_getOverlappingPairCache__SWIG_0 (btBroadphaseInterface *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)(arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btBroadphaseInterface_getOverlappingPairCache__SWIG_1 (btBroadphaseInterface *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)((btBroadphaseInterface const *)arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT void _wrap_btBroadphaseInterface_getBroadphaseAabb (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBroadphaseInterface const *)arg1)->getBroadphaseAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_resetPool (btBroadphaseInterface *larg1, btDispatcher *larg2) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->resetPool(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_printStats (btBroadphaseInterface *larg1) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->printStats();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_sets_set (btDbvtBroadphase *larg1, btDbvt *larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btDbvt *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      btDbvt *b = (btDbvt *) arg1->m_sets;
      for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((btDbvt *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT btDbvt *_wrap_btDbvtBroadphase_m_sets_get (btDbvtBroadphase *larg1) {
  btDbvt * lresult = (btDbvt *)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btDbvt *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDbvt *)(btDbvt *) ((arg1)->m_sets);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDbvt *)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_stageRoots_set (btDbvtBroadphase *larg1, btDbvtProxy **larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btDbvtProxy **arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      btDbvtProxy * *b = (btDbvtProxy * *) arg1->m_stageRoots;
      for (ii = 0; ii < (size_t)btDbvtBroadphase::STAGECOUNT+1; ii++) b[ii] = *((btDbvtProxy * *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT btDbvtProxy **_wrap_btDbvtBroadphase_m_stageRoots_get (btDbvtBroadphase *larg1) {
  btDbvtProxy ** lresult = (btDbvtProxy **)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btDbvtProxy **result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDbvtProxy **)(btDbvtProxy **) ((arg1)->m_stageRoots);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDbvtProxy **)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_paircache_set (btDbvtBroadphase *larg1, btOverlappingPairCache *larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_paircache = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btOverlappingPairCache *_wrap_btDbvtBroadphase_m_paircache_get (btDbvtBroadphase *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *) ((arg1)->m_paircache);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_prediction_set (btDbvtBroadphase *larg1, btScalar larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_prediction = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btDbvtBroadphase_m_prediction_get (btDbvtBroadphase *larg1) {
  btScalar lresult = (btScalar)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_prediction);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_stageCurrent_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stageCurrent = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_stageCurrent_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_stageCurrent);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_fupdates_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_fupdates = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_fupdates_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_fupdates);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_dupdates_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_dupdates = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_dupdates_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_dupdates);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_cupdates_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_cupdates = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_cupdates_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_cupdates);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_newpairs_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_newpairs = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_newpairs_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_newpairs);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_fixedleft_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_fixedleft = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_fixedleft_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_fixedleft);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_updates_call_set (btDbvtBroadphase *larg1, unsigned int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  unsigned int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_updates_call = arg2;
    
  } catch (...) {
    
  }
}


EXPORT unsigned int _wrap_btDbvtBroadphase_m_updates_call_get (btDbvtBroadphase *larg1) {
  unsigned int lresult = (unsigned int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int) ((arg1)->m_updates_call);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_updates_done_set (btDbvtBroadphase *larg1, unsigned int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  unsigned int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_updates_done = arg2;
    
  } catch (...) {
    
  }
}


EXPORT unsigned int _wrap_btDbvtBroadphase_m_updates_done_get (btDbvtBroadphase *larg1) {
  unsigned int lresult = (unsigned int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int) ((arg1)->m_updates_done);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_updates_ratio_set (btDbvtBroadphase *larg1, btScalar larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_updates_ratio = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btDbvtBroadphase_m_updates_ratio_get (btDbvtBroadphase *larg1) {
  btScalar lresult = (btScalar)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_updates_ratio);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_pid_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_pid = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_pid_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_pid);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_cid_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_cid = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_cid_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_cid);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_gid_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_gid = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_gid_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_gid);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_releasepaircache_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_releasepaircache = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_releasepaircache_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_releasepaircache);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_deferedcollide_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_deferedcollide = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_deferedcollide_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_deferedcollide);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_m_needcleanup_set (btDbvtBroadphase *larg1, int larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_needcleanup = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDbvtBroadphase_m_needcleanup_get (btDbvtBroadphase *larg1) {
  int lresult = (int)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_needcleanup);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btDbvtBroadphase *_wrap_new_btDbvtBroadphase_paircache (btOverlappingPairCache *larg1) {
  btDbvtBroadphase * lresult = (btDbvtBroadphase *)0 ;
  btOverlappingPairCache *arg1 = (btOverlappingPairCache *) 0 ;
  btDbvtBroadphase *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDbvtBroadphase *)new btDbvtBroadphase(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDbvtBroadphase *)0;
  }
}


EXPORT btDbvtBroadphase *_wrap_new_btDbvtBroadphase () {
  btDbvtBroadphase * lresult = (btDbvtBroadphase *)0 ;
  btDbvtBroadphase *result = 0 ;
  
  try {
    result = (btDbvtBroadphase *)new btDbvtBroadphase();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDbvtBroadphase *)0;
  }
}


EXPORT void _wrap_delete_btDbvtBroadphase (btDbvtBroadphase *larg1) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_collide (btDbvtBroadphase *larg1, btDispatcher *larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->collide(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_optimize (btDbvtBroadphase *larg1) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->optimize();
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseProxy *_wrap_btDbvtBroadphase_createProxy (btDbvtBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, int larg4, void *larg5, short larg6, short larg7, btDispatcher *larg8, void *larg9) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  short arg6 ;
  short arg7 ;
  btDispatcher *arg8 = (btDispatcher *) 0 ;
  void *arg9 = (void *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btBroadphaseProxy *)(arg1)->createProxy((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_destroyProxy (btDbvtBroadphase *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->destroyProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_setAabb (btDbvtBroadphase *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4, btDispatcher *larg5) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setAabb(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_rayTest__SWIG_0 (btDbvtBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5, btVector3 *larg6) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_rayTest__SWIG_1 (btDbvtBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_rayTest__SWIG_2 (btDbvtBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_aabbTest (btDbvtBroadphase *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseAabbCallback *larg4) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseAabbCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->aabbTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_getAabb (btDbvtBroadphase *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btDbvtBroadphase const *)arg1)->getAabb(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_calculateOverlappingPairs (btDbvtBroadphase *larg1, btDispatcher *larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->calculateOverlappingPairs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btOverlappingPairCache *_wrap_btDbvtBroadphase_getOverlappingPairCache__SWIG_0 (btDbvtBroadphase *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)(arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btDbvtBroadphase_getOverlappingPairCache__SWIG_1 (btDbvtBroadphase *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)((btDbvtBroadphase const *)arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_getBroadphaseAabb (btDbvtBroadphase *larg1, btVector3 *larg2, btVector3 *larg3) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btDbvtBroadphase const *)arg1)->getBroadphaseAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_printStats (btDbvtBroadphase *larg1) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->printStats();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_resetPool (btDbvtBroadphase *larg1, btDispatcher *larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->resetPool(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_performDeferredRemoval (btDbvtBroadphase *larg1, btDispatcher *larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->performDeferredRemoval(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_setVelocityPrediction (btDbvtBroadphase *larg1, btScalar larg2) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setVelocityPrediction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btDbvtBroadphase_getVelocityPrediction (btDbvtBroadphase *larg1) {
  btScalar lresult = (btScalar)0 ;
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btDbvtBroadphase const *)arg1)->getVelocityPrediction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btDbvtBroadphase_setAabbForceUpdate (btDbvtBroadphase *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4, btDispatcher *larg5) {
  btDbvtBroadphase *arg1 = (btDbvtBroadphase *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setAabbForceUpdate(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDbvtBroadphase_benchmark (btBroadphaseInterface *larg1) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  try {
    btDbvtBroadphase::benchmark(arg1);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btCollisionConfiguration (btCollisionConfiguration *larg1) {
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionConfiguration_getPersistentManifoldPool (btCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getPersistentManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionConfiguration_getCollisionAlgorithmPool (btCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getCollisionAlgorithmPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btCollisionAlgorithmCreateFunc *_wrap_btCollisionConfiguration_getCollisionAlgorithmCreateFunc (btCollisionConfiguration *larg1, int larg2, int larg3) {
  btCollisionAlgorithmCreateFunc * lresult = (btCollisionAlgorithmCreateFunc *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithmCreateFunc *)(arg1)->getCollisionAlgorithmCreateFunc(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithmCreateFunc *)0;
  }
}


EXPORT btDefaultCollisionConfiguration *_wrap_new_btDefaultCollisionConfiguration_1 (btDefaultCollisionConstructionInfo *larg1) {
  btDefaultCollisionConfiguration * lresult = (btDefaultCollisionConfiguration *)0 ;
  btDefaultCollisionConstructionInfo *arg1 = 0 ;
  btDefaultCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDefaultCollisionConfiguration *)new btDefaultCollisionConfiguration((btDefaultCollisionConstructionInfo const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultCollisionConfiguration *)0;
  }
}


EXPORT btDefaultCollisionConfiguration *_wrap_new_btDefaultCollisionConfiguration_0 () {
  btDefaultCollisionConfiguration * lresult = (btDefaultCollisionConfiguration *)0 ;
  btDefaultCollisionConfiguration *result = 0 ;
  
  try {
    result = (btDefaultCollisionConfiguration *)new btDefaultCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultCollisionConfiguration *)0;
  }
}


EXPORT void _wrap_delete_btDefaultCollisionConfiguration (btDefaultCollisionConfiguration *larg1) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btPoolAllocator *_wrap_btDefaultCollisionConfiguration_getPersistentManifoldPool (btDefaultCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getPersistentManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btDefaultCollisionConfiguration_getCollisionAlgorithmPool (btDefaultCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getCollisionAlgorithmPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btVoronoiSimplexSolver *_wrap_btDefaultCollisionConfiguration_getSimplexSolver (btDefaultCollisionConfiguration *larg1) {
  btVoronoiSimplexSolver * lresult = (btVoronoiSimplexSolver *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  btVoronoiSimplexSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVoronoiSimplexSolver *)(arg1)->getSimplexSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVoronoiSimplexSolver *)0;
  }
}


EXPORT btCollisionAlgorithmCreateFunc *_wrap_btDefaultCollisionConfiguration_getCollisionAlgorithmCreateFunc (btDefaultCollisionConfiguration *larg1, int larg2, int larg3) {
  btCollisionAlgorithmCreateFunc * lresult = (btCollisionAlgorithmCreateFunc *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithmCreateFunc *)(arg1)->getCollisionAlgorithmCreateFunc(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithmCreateFunc *)0;
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setConvexConvexMultipointIterations__SWIG_0 (btDefaultCollisionConfiguration *larg1, int larg2, int larg3) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setConvexConvexMultipointIterations(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setConvexConvexMultipointIterations__SWIG_1 (btDefaultCollisionConfiguration *larg1, int larg2) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConvexConvexMultipointIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setConvexConvexMultipointIterations__SWIG_2 (btDefaultCollisionConfiguration *larg1) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setConvexConvexMultipointIterations();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations__SWIG_0 (btDefaultCollisionConfiguration *larg1, int larg2, int larg3) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setPlaneConvexMultipointIterations(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations__SWIG_1 (btDefaultCollisionConfiguration *larg1, int larg2) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPlaneConvexMultipointIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations__SWIG_2 (btDefaultCollisionConfiguration *larg1) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setPlaneConvexMultipointIterations();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionDispatcher_getDispatcherFlags (btCollisionDispatcher *larg1) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionDispatcher const *)arg1)->getDispatcherFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_setDispatcherFlags (btCollisionDispatcher *larg1, int larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDispatcherFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionDispatcher_registerCollisionCreateFunc (btCollisionDispatcher *larg1, int larg2, int larg3, btCollisionAlgorithmCreateFunc *larg4) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *arg4 = (btCollisionAlgorithmCreateFunc *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->registerCollisionCreateFunc(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionDispatcher_getNumManifolds (btCollisionDispatcher *larg1) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionDispatcher const *)arg1)->getNumManifolds();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btPersistentManifold **_wrap_btCollisionDispatcher_getInternalManifoldPointer (btCollisionDispatcher *larg1) {
  btPersistentManifold ** lresult = (btPersistentManifold **)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold **result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPersistentManifold **)(arg1)->getInternalManifoldPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold **)0;
  }
}


EXPORT btPersistentManifold *_wrap_btCollisionDispatcher_getManifoldByIndexInternal__SWIG_0 (btCollisionDispatcher *larg1, int larg2) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPersistentManifold *)(arg1)->getManifoldByIndexInternal(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btPersistentManifold *_wrap_btCollisionDispatcher_getManifoldByIndexInternal__SWIG_1 (btCollisionDispatcher *larg1, int larg2) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPersistentManifold *)((btCollisionDispatcher const *)arg1)->getManifoldByIndexInternal(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btCollisionDispatcher *_wrap_new_btCollisionDispatcher (btCollisionConfiguration *larg1) {
  btCollisionDispatcher * lresult = (btCollisionDispatcher *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btCollisionDispatcher *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionDispatcher *)new btCollisionDispatcher(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionDispatcher *)0;
  }
}


EXPORT void _wrap_delete_btCollisionDispatcher (btCollisionDispatcher *larg1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btPersistentManifold *_wrap_btCollisionDispatcher_getNewManifold (btCollisionDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btPersistentManifold *)(arg1)->getNewManifold((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_releaseManifold (btCollisionDispatcher *larg1, btPersistentManifold *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->releaseManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionDispatcher_clearManifold (btCollisionDispatcher *larg1, btPersistentManifold *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->clearManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionAlgorithm *_wrap_btCollisionDispatcher_findAlgorithm__SWIG_0 (btCollisionDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3, btPersistentManifold *larg4) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btPersistentManifold *arg4 = (btPersistentManifold *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT btCollisionAlgorithm *_wrap_btCollisionDispatcher_findAlgorithm__SWIG_1 (btCollisionDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT int _wrap_btCollisionDispatcher_needsCollision (btCollisionDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsCollision((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionDispatcher_needsResponse (btCollisionDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsResponse((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_dispatchAllCollisionPairs (btCollisionDispatcher *larg1, btOverlappingPairCache *larg2, btDispatcherInfo *larg3, btDispatcher *larg4) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  btDispatcherInfo *arg3 = 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->dispatchAllCollisionPairs(arg2,(btDispatcherInfo const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionDispatcher_setNearCallback (btCollisionDispatcher *larg1, btNearCallback larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btNearCallback arg2 = (btNearCallback) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNearCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btNearCallback _wrap_btCollisionDispatcher_getNearCallback (btCollisionDispatcher *larg1) {
  btNearCallback lresult = (btNearCallback)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btNearCallback result;
  
  arg1 = larg1;
  try {
    result = (btNearCallback)((btCollisionDispatcher const *)arg1)->getNearCallback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btNearCallback)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_defaultNearCallback (btBroadphasePair *larg1, btCollisionDispatcher *larg2, btDispatcherInfo *larg3) {
  btBroadphasePair *arg1 = 0 ;
  btCollisionDispatcher *arg2 = 0 ;
  btDispatcherInfo *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btCollisionDispatcher::defaultNearCallback(*arg1,*arg2,(btDispatcherInfo const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btCollisionDispatcher_allocateCollisionAlgorithm (btCollisionDispatcher *larg1, int larg2) {
  void * lresult = (void *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (void *)(arg1)->allocateCollisionAlgorithm(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_freeCollisionAlgorithm (btCollisionDispatcher *larg1, void *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->freeCollisionAlgorithm(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionConfiguration *_wrap_btCollisionDispatcher_getCollisionConfiguration__SWIG_0 (btCollisionDispatcher *larg1) {
  btCollisionConfiguration * lresult = (btCollisionConfiguration *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionConfiguration *)(arg1)->getCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionConfiguration *)0;
  }
}


EXPORT btCollisionConfiguration *_wrap_btCollisionDispatcher_getCollisionConfiguration__SWIG_1 (btCollisionDispatcher *larg1) {
  btCollisionConfiguration * lresult = (btCollisionConfiguration *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionConfiguration *)((btCollisionDispatcher const *)arg1)->getCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionConfiguration *)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_setCollisionConfiguration (btCollisionDispatcher *larg1, btCollisionConfiguration *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *arg2 = (btCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionConfiguration(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionDispatcher_getInternalManifoldPool__SWIG_0 (btCollisionDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionDispatcher_getInternalManifoldPool__SWIG_1 (btCollisionDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)((btCollisionDispatcher const *)arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT int _wrap_btCollisionObject_mergesSimulationIslands (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->mergesSimulationIslands();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btCollisionObject_getAnisotropicFriction (btCollisionObject *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionObject const *)arg1)->getAnisotropicFriction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_0 (btCollisionObject *larg1, btVector3 *larg2, int larg3) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAnisotropicFriction((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_1 (btCollisionObject *larg1, btVector3 *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAnisotropicFriction((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_0 (btCollisionObject *larg1, int larg2) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_1 (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setContactProcessingThreshold (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setContactProcessingThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getContactProcessingThreshold (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getContactProcessingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btCollisionObject_isStaticObject (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isStaticObject();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_isKinematicObject (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isKinematicObject();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_isStaticOrKinematicObject (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isStaticOrKinematicObject();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_hasContactResponse (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->hasContactResponse();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btCollisionObject *_wrap_new_btCollisionObject () {
  btCollisionObject * lresult = (btCollisionObject *)0 ;
  btCollisionObject *result = 0 ;
  
  try {
    result = (btCollisionObject *)new btCollisionObject();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObject *)0;
  }
}


EXPORT void _wrap_delete_btCollisionObject (btCollisionObject *larg1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setCollisionShape (btCollisionObject *larg1, btCollisionShape *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionShape(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_0 (btCollisionObject *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)((btCollisionObject const *)arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_1 (btCollisionObject *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)(arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT void *_wrap_btCollisionObject_internalGetExtensionPointer (btCollisionObject *larg1) {
  void * lresult = (void *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btCollisionObject const *)arg1)->internalGetExtensionPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btCollisionObject_internalSetExtensionPointer (btCollisionObject *larg1, void *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->internalSetExtensionPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getActivationState (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getActivationState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setActivationState (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionObject const *)arg1)->setActivationState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setDeactivationTime (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDeactivationTime(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getDeactivationTime (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getDeactivationTime();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_forceActivationState (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionObject const *)arg1)->forceActivationState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_activate__SWIG_0 (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    ((btCollisionObject const *)arg1)->activate(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_activate__SWIG_1 (btCollisionObject *larg1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  try {
    ((btCollisionObject const *)arg1)->activate();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_isActive (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isActive();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setRestitution (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitution(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getRestitution (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getRestitution();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setFriction (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFriction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getFriction (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getFriction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setRollingFriction (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRollingFriction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getRollingFriction (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getRollingFriction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btCollisionObject_getInternalType (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getInternalType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_0 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_1 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btCollisionObject const *)arg1)->getWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setWorldTransform (btCollisionObject *larg1, btTransform *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_0 (btCollisionObject *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)(arg1)->getBroadphaseHandle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_1 (btCollisionObject *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)((btCollisionObject const *)arg1)->getBroadphaseHandle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setBroadphaseHandle (btCollisionObject *larg1, btBroadphaseProxy *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBroadphaseHandle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_0 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btCollisionObject const *)arg1)->getInterpolationWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_1 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getInterpolationWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setInterpolationWorldTransform (btCollisionObject *larg1, btTransform *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInterpolationWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setInterpolationLinearVelocity (btCollisionObject *larg1, btVector3 *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInterpolationLinearVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setInterpolationAngularVelocity (btCollisionObject *larg1, btVector3 *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInterpolationAngularVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCollisionObject_getInterpolationLinearVelocity (btCollisionObject *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationLinearVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btCollisionObject_getInterpolationAngularVelocity (btCollisionObject *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationAngularVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btCollisionObject_getIslandTag (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getIslandTag();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setIslandTag (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setIslandTag(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getCompanionId (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getCompanionId();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCompanionId (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCompanionId(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getHitFraction (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getHitFraction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setHitFraction (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setHitFraction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getCollisionFlags (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getCollisionFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCollisionFlags (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getCcdSweptSphereRadius (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getCcdSweptSphereRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCcdSweptSphereRadius (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCcdSweptSphereRadius(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getCcdMotionThreshold (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getCcdMotionThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCollisionObject_getCcdSquareMotionThreshold (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getCcdSquareMotionThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCcdMotionThreshold (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCcdMotionThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btCollisionObject_getUserPointer (btCollisionObject *larg1) {
  void * lresult = (void *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btCollisionObject const *)arg1)->getUserPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT int _wrap_btCollisionObject_getUserIndex (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getUserIndex();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setUserPointer (btCollisionObject *larg1, void *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setUserIndex (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserIndex(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getUpdateRevisionInternal (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getUpdateRevisionInternal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_checkCollideWith (btCollisionObject *larg1, btCollisionObject *larg2) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btCollisionObject const *)arg1)->checkCollideWith((btCollisionObject const *)arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_calculateSerializeBufferSize (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCollisionObject_serialize (btCollisionObject *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCollisionObject const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btCollisionObject_serializeSingleObject (btCollisionObject *larg1, btSerializer *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionObject const *)arg1)->serializeSingleObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionWorld *_wrap_new_btCollisionWorld (btDispatcher *larg1, btBroadphaseInterface *larg2, btCollisionConfiguration *larg3) {
  btCollisionWorld * lresult = (btCollisionWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btCollisionConfiguration *arg3 = (btCollisionConfiguration *) 0 ;
  btCollisionWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionWorld *)new btCollisionWorld(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionWorld *)0;
  }
}


EXPORT void _wrap_delete_btCollisionWorld (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_setBroadphase (btCollisionWorld *larg1, btBroadphaseInterface *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBroadphase(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_0 (btCollisionWorld *larg1) {
  btBroadphaseInterface * lresult = (btBroadphaseInterface *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseInterface *)((btCollisionWorld const *)arg1)->getBroadphase();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseInterface *)0;
  }
}


EXPORT btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_1 (btCollisionWorld *larg1) {
  btBroadphaseInterface * lresult = (btBroadphaseInterface *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseInterface *)(arg1)->getBroadphase();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseInterface *)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btCollisionWorld_getPairCache (btCollisionWorld *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)(arg1)->getPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_0 (btCollisionWorld *larg1) {
  btDispatcher * lresult = (btDispatcher *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcher *)(arg1)->getDispatcher();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcher *)0;
  }
}


EXPORT btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_1 (btCollisionWorld *larg1) {
  btDispatcher * lresult = (btDispatcher *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcher *)((btCollisionWorld const *)arg1)->getDispatcher();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcher *)0;
  }
}


EXPORT void _wrap_btCollisionWorld_updateSingleAabb (btCollisionWorld *larg1, btCollisionObject *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateSingleAabb(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_updateAabbs (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateAabbs();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_computeOverlappingPairs (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->computeOverlappingPairs();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_setDebugDrawer (btCollisionWorld *larg1, btIDebugDraw *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDebugDrawer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btIDebugDraw *_wrap_btCollisionWorld_getDebugDrawer (btCollisionWorld *larg1) {
  btIDebugDraw * lresult = (btIDebugDraw *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btIDebugDraw *)(arg1)->getDebugDrawer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btIDebugDraw *)0;
  }
}


EXPORT void _wrap_btCollisionWorld_debugDrawWorld (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_debugDrawObject (btCollisionWorld *larg1, btTransform *larg2, btCollisionShape *larg3, btVector3 *larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btTransform *arg2 = 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->debugDrawObject((btTransform const &)*arg2,(btCollisionShape const *)arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionWorld_getNumCollisionObjects (btCollisionWorld *larg1) {
  int lresult = (int)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionWorld const *)arg1)->getNumCollisionObjects();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionWorld_rayTest (btCollisionWorld *larg1, btVector3 *larg2, btVector3 *larg3, btCollisionWorld::RayResultCallback *larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCollisionWorld const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_convexSweepTest__SWIG_0 (btCollisionWorld *larg1, btConvexShape *larg2, btTransform *larg3, btTransform *larg4, btCollisionWorld::ConvexResultCallback *larg5, btScalar larg6) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_convexSweepTest__SWIG_1 (btCollisionWorld *larg1, btConvexShape *larg2, btTransform *larg3, btTransform *larg4, btCollisionWorld::ConvexResultCallback *larg5) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_contactTest (btCollisionWorld *larg1, btCollisionObject *larg2, btCollisionWorld::ContactResultCallback *larg3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->contactTest(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_contactPairTest (btCollisionWorld *larg1, btCollisionObject *larg2, btCollisionObject *larg3, btCollisionWorld::ContactResultCallback *larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->contactPairTest(arg2,arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_rayTestSingle (btTransform *larg1, btTransform *larg2, btCollisionObject *larg3, btCollisionShape *larg4, btTransform *larg5, btCollisionWorld::RayResultCallback *larg6) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  btTransform *arg5 = 0 ;
  btCollisionWorld::RayResultCallback *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    btCollisionWorld::rayTestSingle((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,(btCollisionShape const *)arg4,(btTransform const &)*arg5,*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_rayTestSingleInternal (btTransform *larg1, btTransform *larg2, btCollisionObjectWrapper *larg3, btCollisionWorld::RayResultCallback *larg4) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    btCollisionWorld::rayTestSingleInternal((btTransform const &)*arg1,(btTransform const &)*arg2,(btCollisionObjectWrapper const *)arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_objectQuerySingle (btConvexShape *larg1, btTransform *larg2, btTransform *larg3, btCollisionObject *larg4, btCollisionShape *larg5, btTransform *larg6, btCollisionWorld::ConvexResultCallback *larg7, btScalar larg8) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObject *arg4 = (btCollisionObject *) 0 ;
  btCollisionShape *arg5 = (btCollisionShape *) 0 ;
  btTransform *arg6 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg7 = 0 ;
  btScalar arg8 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    btCollisionWorld::objectQuerySingle((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,arg4,(btCollisionShape const *)arg5,(btTransform const &)*arg6,*arg7,arg8);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_objectQuerySingleInternal (btConvexShape *larg1, btTransform *larg2, btTransform *larg3, btCollisionObjectWrapper *larg4, btCollisionWorld::ConvexResultCallback *larg5, btScalar larg6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObjectWrapper *arg4 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    btCollisionWorld::objectQuerySingleInternal((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,(btCollisionObjectWrapper const *)arg4,*arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_addCollisionObject__SWIG_0 (btCollisionWorld *larg1, btCollisionObject *larg2, short larg3, short larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addCollisionObject(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_addCollisionObject__SWIG_1 (btCollisionWorld *larg1, btCollisionObject *larg2, short larg3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addCollisionObject(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_addCollisionObject__SWIG_2 (btCollisionWorld *larg1, btCollisionObject *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionObjectArray *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_0 (btCollisionWorld *larg1) {
  btCollisionObjectArray * lresult = (btCollisionObjectArray *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObjectArray *) &(arg1)->getCollisionObjectArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObjectArray *)0;
  }
}


EXPORT btCollisionObjectArray *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_1 (btCollisionWorld *larg1) {
  btCollisionObjectArray * lresult = (btCollisionObjectArray *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObjectArray *) &((btCollisionWorld const *)arg1)->getCollisionObjectArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObjectArray *)0;
  }
}


EXPORT void _wrap_btCollisionWorld_removeCollisionObject (btCollisionWorld *larg1, btCollisionObject *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_performDiscreteCollisionDetection (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->performDiscreteCollisionDetection();
    
  } catch (...) {
    
  }
}


EXPORT btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_0 (btCollisionWorld *larg1) {
  btDispatcherInfo * lresult = (btDispatcherInfo *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcherInfo *) &(arg1)->getDispatchInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcherInfo *)0;
  }
}


EXPORT btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_1 (btCollisionWorld *larg1) {
  btDispatcherInfo * lresult = (btDispatcherInfo *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcherInfo *) &((btCollisionWorld const *)arg1)->getDispatchInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcherInfo *)0;
  }
}


EXPORT int _wrap_btCollisionWorld_getForceUpdateAllAabbs (btCollisionWorld *larg1) {
  int lresult = (int)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionWorld const *)arg1)->getForceUpdateAllAabbs();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionWorld_setForceUpdateAllAabbs (btCollisionWorld *larg1, int larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setForceUpdateAllAabbs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_serialize (btCollisionWorld *larg1, btSerializer *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serialize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btGhostObject *_wrap_new_btGhostObject () {
  btGhostObject * lresult = (btGhostObject *)0 ;
  btGhostObject *result = 0 ;
  
  try {
    result = (btGhostObject *)new btGhostObject();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGhostObject *)0;
  }
}


EXPORT void _wrap_delete_btGhostObject (btGhostObject *larg1) {
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGhostObject_convexSweepTest__SWIG_0 (btGhostObject *larg1, btConvexShape *larg2, btTransform *larg3, btTransform *larg4, btCollisionWorld::ConvexResultCallback *larg5, btScalar larg6) {
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    ((btGhostObject const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGhostObject_convexSweepTest__SWIG_1 (btGhostObject *larg1, btConvexShape *larg2, btTransform *larg3, btTransform *larg4, btCollisionWorld::ConvexResultCallback *larg5) {
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btGhostObject const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGhostObject_rayTest (btGhostObject *larg1, btVector3 *larg2, btVector3 *larg3, btCollisionWorld::RayResultCallback *larg4) {
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btGhostObject const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGhostObject_addOverlappingObjectInternal__SWIG_0 (btGhostObject *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addOverlappingObjectInternal(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGhostObject_addOverlappingObjectInternal__SWIG_1 (btGhostObject *larg1, btBroadphaseProxy *larg2) {
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addOverlappingObjectInternal(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGhostObject_removeOverlappingObjectInternal__SWIG_0 (btGhostObject *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3, btBroadphaseProxy *larg4) {
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  btBroadphaseProxy *arg4 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->removeOverlappingObjectInternal(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGhostObject_removeOverlappingObjectInternal__SWIG_1 (btGhostObject *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->removeOverlappingObjectInternal(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGhostObject_getNumOverlappingObjects (btGhostObject *larg1) {
  int lresult = (int)0 ;
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btGhostObject const *)arg1)->getNumOverlappingObjects();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btCollisionObject *_wrap_btGhostObject_getOverlappingObject__SWIG_0 (btGhostObject *larg1, int larg2) {
  btCollisionObject * lresult = (btCollisionObject *)0 ;
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  int arg2 ;
  btCollisionObject *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCollisionObject *)(arg1)->getOverlappingObject(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObject *)0;
  }
}


EXPORT btCollisionObject *_wrap_btGhostObject_getOverlappingObject__SWIG_1 (btGhostObject *larg1, int larg2) {
  btCollisionObject * lresult = (btCollisionObject *)0 ;
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  int arg2 ;
  btCollisionObject *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCollisionObject *)((btGhostObject const *)arg1)->getOverlappingObject(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObject *)0;
  }
}


EXPORT btAlignedObjectArray< btCollisionObject * > *_wrap_btGhostObject_getOverlappingPairs__SWIG_0 (btGhostObject *larg1) {
  btAlignedObjectArray< btCollisionObject * > * lresult = (btAlignedObjectArray< btCollisionObject * > *)0 ;
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  btAlignedObjectArray< btCollisionObject * > *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btAlignedObjectArray< btCollisionObject * > *) &(arg1)->getOverlappingPairs();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAlignedObjectArray< btCollisionObject * > *)0;
  }
}


EXPORT btAlignedObjectArray< btCollisionObject * > const *_wrap_btGhostObject_getOverlappingPairs__SWIG_1 (btGhostObject *larg1) {
  btAlignedObjectArray< btCollisionObject * > const * lresult = (btAlignedObjectArray< btCollisionObject * > const *)0 ;
  btGhostObject *arg1 = (btGhostObject *) 0 ;
  SwigValueWrapper< btAlignedObjectArray< btCollisionObject * > > result;
  
  arg1 = larg1;
  try {
    result = ((btGhostObject const *)arg1)->getOverlappingPairs();
    lresult = new btAlignedObjectArray< btCollisionObject * > const(result);
    return lresult;
  } catch (...) {
    return (btAlignedObjectArray< btCollisionObject * > const *)0;
  }
}


EXPORT btGhostObject *_wrap_btGhostObject_upcast__SWIG_0 (btCollisionObject *larg1) {
  btGhostObject * lresult = (btGhostObject *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btGhostObject *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btGhostObject *)btGhostObject::upcast((btCollisionObject const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGhostObject *)0;
  }
}


EXPORT btGhostObject *_wrap_btGhostObject_upcast__SWIG_1 (btCollisionObject *larg1) {
  btGhostObject * lresult = (btGhostObject *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btGhostObject *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btGhostObject *)btGhostObject::upcast(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGhostObject *)0;
  }
}


EXPORT btPairCachingGhostObject *_wrap_new_btPairCachingGhostObject () {
  btPairCachingGhostObject * lresult = (btPairCachingGhostObject *)0 ;
  btPairCachingGhostObject *result = 0 ;
  
  try {
    result = (btPairCachingGhostObject *)new btPairCachingGhostObject();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPairCachingGhostObject *)0;
  }
}


EXPORT void _wrap_delete_btPairCachingGhostObject (btPairCachingGhostObject *larg1) {
  btPairCachingGhostObject *arg1 = (btPairCachingGhostObject *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPairCachingGhostObject_addOverlappingObjectInternal__SWIG_0 (btPairCachingGhostObject *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btPairCachingGhostObject *arg1 = (btPairCachingGhostObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addOverlappingObjectInternal(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPairCachingGhostObject_addOverlappingObjectInternal__SWIG_1 (btPairCachingGhostObject *larg1, btBroadphaseProxy *larg2) {
  btPairCachingGhostObject *arg1 = (btPairCachingGhostObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addOverlappingObjectInternal(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPairCachingGhostObject_removeOverlappingObjectInternal__SWIG_0 (btPairCachingGhostObject *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3, btBroadphaseProxy *larg4) {
  btPairCachingGhostObject *arg1 = (btPairCachingGhostObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  btBroadphaseProxy *arg4 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->removeOverlappingObjectInternal(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPairCachingGhostObject_removeOverlappingObjectInternal__SWIG_1 (btPairCachingGhostObject *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btPairCachingGhostObject *arg1 = (btPairCachingGhostObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->removeOverlappingObjectInternal(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btHashedOverlappingPairCache *_wrap_btPairCachingGhostObject_getOverlappingPairCache (btPairCachingGhostObject *larg1) {
  btHashedOverlappingPairCache * lresult = (btHashedOverlappingPairCache *)0 ;
  btPairCachingGhostObject *arg1 = (btPairCachingGhostObject *) 0 ;
  btHashedOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btHashedOverlappingPairCache *)(arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHashedOverlappingPairCache *)0;
  }
}


EXPORT btGhostPairCallback *_wrap_new_btGhostPairCallback () {
  btGhostPairCallback * lresult = (btGhostPairCallback *)0 ;
  btGhostPairCallback *result = 0 ;
  
  try {
    result = (btGhostPairCallback *)new btGhostPairCallback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGhostPairCallback *)0;
  }
}


EXPORT void _wrap_delete_btGhostPairCallback (btGhostPairCallback *larg1) {
  btGhostPairCallback *arg1 = (btGhostPairCallback *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btBroadphasePair *_wrap_btGhostPairCallback_addOverlappingPair (btGhostPairCallback *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3) {
  btBroadphasePair * lresult = (btBroadphasePair *)0 ;
  btGhostPairCallback *arg1 = (btGhostPairCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btBroadphasePair *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btBroadphasePair *)(arg1)->addOverlappingPair(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePair *)0;
  }
}


EXPORT void *_wrap_btGhostPairCallback_removeOverlappingPair (btGhostPairCallback *larg1, btBroadphaseProxy *larg2, btBroadphaseProxy *larg3, btDispatcher *larg4) {
  void * lresult = (void *)0 ;
  btGhostPairCallback *arg1 = (btGhostPairCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btBroadphaseProxy *arg3 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (void *)(arg1)->removeOverlappingPair(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btGhostPairCallback_removeOverlappingPairsContainingProxy (btGhostPairCallback *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btGhostPairCallback *arg1 = (btGhostPairCallback *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->removeOverlappingPairsContainingProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btCollisionShape (btCollisionShape *larg1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionShape_getAabb (btCollisionShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCollisionShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionShape_getBoundingSphere (btCollisionShape *larg1, btVector3 *larg2, btScalar *larg3) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCollisionShape const *)arg1)->getBoundingSphere(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionShape_getAngularMotionDisc (btCollisionShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionShape const *)arg1)->getAngularMotionDisc();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCollisionShape_getContactBreakingThreshold (btCollisionShape *larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btCollisionShape const *)arg1)->getContactBreakingThreshold(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionShape_calculateTemporalAabb (btCollisionShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5, btVector3 *larg6, btVector3 *larg7) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    ((btCollisionShape const *)arg1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionShape_isPolyhedral (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isPolyhedral();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isConvex2d (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isConvex2d();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isConvex (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isConvex();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isNonMoving (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isNonMoving();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isConcave (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isConcave();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isCompound (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isCompound();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isSoftBody (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isSoftBody();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isInfinite (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isInfinite();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionShape_setLocalScaling (btCollisionShape *larg1, btVector3 *larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCollisionShape_getLocalScaling (btCollisionShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCollisionShape_calculateLocalInertia (btCollisionShape *larg1, btScalar larg2, btVector3 *larg3) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCollisionShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btCollisionShape_getName (btCollisionShape *larg1) {
  char * lresult = (char *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCollisionShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btCollisionShape_getShapeType (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionShape const *)arg1)->getShapeType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btCollisionShape_getAnisotropicRollingFrictionDirection (btCollisionShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btCollisionShape const *)arg1)->getAnisotropicRollingFrictionDirection();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCollisionShape_setMargin (btCollisionShape *larg1, btScalar larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionShape_getMargin (btCollisionShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionShape_setUserPointer (btCollisionShape *larg1, void *larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btCollisionShape_getUserPointer (btCollisionShape *larg1) {
  void * lresult = (void *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btCollisionShape const *)arg1)->getUserPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT int _wrap_btCollisionShape_calculateSerializeBufferSize (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCollisionShape_serialize (btCollisionShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCollisionShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btCollisionShape_serializeSingleShape (btCollisionShape *larg1, btSerializer *larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionShape const *)arg1)->serializeSingleShape(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexShape (btConvexShape *larg1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportingVertex (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportingVertexWithoutMargin (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportVertexWithoutMarginNonVirtual (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportVertexNonVirtual (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btConvexShape_getMarginNonVirtual (btConvexShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexShape const *)arg1)->getMarginNonVirtual();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConvexShape_getAabbNonVirtual (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_project (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btScalar *larg4, btScalar *larg5) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btConvexShape const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btConvexShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_getAabb (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_getAabbSlow (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_setLocalScaling (btConvexShape *larg1, btVector3 *larg2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexShape_getLocalScaling (btConvexShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexShape_setMargin (btConvexShape *larg1, btScalar larg2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConvexShape_getMargin (btConvexShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConvexShape_getNumPreferredPenetrationDirections (btConvexShape *larg1) {
  int lresult = (int)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexShape_getPreferredPenetrationDirection (btConvexShape *larg1, int larg2, btVector3 *larg3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexInternalShape (btConvexInternalShape *larg1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_localGetSupportingVertex (btConvexInternalShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexInternalShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_getImplicitShapeDimensions (btConvexInternalShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getImplicitShapeDimensions();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexInternalShape_setImplicitShapeDimensions (btConvexInternalShape *larg1, btVector3 *larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_0 (btConvexInternalShape *larg1, btScalar larg2, btScalar larg3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSafeMargin(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_1 (btConvexInternalShape *larg1, btScalar larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSafeMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_2 (btConvexInternalShape *larg1, btVector3 *larg2, btScalar larg3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSafeMargin((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_3 (btConvexInternalShape *larg1, btVector3 *larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSafeMargin((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_getAabb (btConvexInternalShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexInternalShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_getAabbSlow (btConvexInternalShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexInternalShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setLocalScaling (btConvexInternalShape *larg1, btVector3 *larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_getLocalScaling (btConvexInternalShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_getLocalScalingNV (btConvexInternalShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScalingNV();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexInternalShape_setMargin (btConvexInternalShape *larg1, btScalar larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConvexInternalShape_getMargin (btConvexInternalShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexInternalShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConvexInternalShape_getMarginNV (btConvexInternalShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexInternalShape const *)arg1)->getMarginNV();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConvexInternalShape_getNumPreferredPenetrationDirections (btConvexInternalShape *larg1) {
  int lresult = (int)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexInternalShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexInternalShape_getPreferredPenetrationDirection (btConvexInternalShape *larg1, int larg2, btVector3 *larg3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexInternalShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexInternalShape_calculateSerializeBufferSize (btConvexInternalShape *larg1) {
  int lresult = (int)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexInternalShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConvexInternalShape_serialize (btConvexInternalShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConvexInternalShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btConvexInternalAabbCachingShape_setLocalScaling (btConvexInternalAabbCachingShape *larg1, btVector3 *larg2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalAabbCachingShape_getAabb (btConvexInternalAabbCachingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexInternalAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalAabbCachingShape_recalcLocalAabb (btConvexInternalAabbCachingShape *larg1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->recalcLocalAabb();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexInternalAabbCachingShape (btConvexInternalAabbCachingShape *larg1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btPolyhedralConvexShape (btPolyhedralConvexShape *larg1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_0 (btPolyhedralConvexShape *larg1, int larg2) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->initializePolyhedralFeatures(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_1 (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->initializePolyhedralFeatures();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btConvexPolyhedron *_wrap_btPolyhedralConvexShape_getConvexPolyhedron (btPolyhedralConvexShape *larg1) {
  btConvexPolyhedron * lresult = (btConvexPolyhedron *)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)arg1)->getConvexPolyhedron();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexPolyhedron *)0;
  }
}


EXPORT btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin (btPolyhedralConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btPolyhedralConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btPolyhedralConvexShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_calculateLocalInertia (btPolyhedralConvexShape *larg1, btScalar larg2, btVector3 *larg3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btPolyhedralConvexShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_getNumVertices (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPolyhedralConvexShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_getNumEdges (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPolyhedralConvexShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_getEdge (btPolyhedralConvexShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_getVertex (btPolyhedralConvexShape *larg1, int larg2, btVector3 *larg3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btPolyhedralConvexShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_getNumPlanes (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPolyhedralConvexShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_getPlane (btPolyhedralConvexShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_isInside (btPolyhedralConvexShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btPolyhedralConvexShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_getNonvirtualAabb (btPolyhedralConvexAabbCachingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btPolyhedralConvexAabbCachingShape const *)arg1)->getNonvirtualAabb((btTransform const &)*arg2,*arg3,*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_setLocalScaling (btPolyhedralConvexAabbCachingShape *larg1, btVector3 *larg2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_getAabb (btPolyhedralConvexAabbCachingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_recalcLocalAabb (btPolyhedralConvexAabbCachingShape *larg1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->recalcLocalAabb();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btPolyhedralConvexAabbCachingShape (btPolyhedralConvexAabbCachingShape *larg1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape_3 (btScalar *larg1, int larg2, int larg3) {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  int arg2 ;
  int arg3 ;
  btConvexHullShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btConvexHullShape *)new btConvexHullShape((btScalar const *)arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape_2 (btScalar *larg1, int larg2) {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  int arg2 ;
  btConvexHullShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConvexHullShape *)new btConvexHullShape((btScalar const *)arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape_1 (btScalar *larg1) {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  btConvexHullShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConvexHullShape *)new btConvexHullShape((btScalar const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape_0 () {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btConvexHullShape *result = 0 ;
  
  try {
    result = (btConvexHullShape *)new btConvexHullShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT void _wrap_btConvexHullShape_addPoint__SWIG_0 (btConvexHullShape *larg1, btVector3 *larg2, int larg3) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->addPoint((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexHullShape_addPoint__SWIG_1 (btConvexHullShape *larg1, btVector3 *larg2) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addPoint((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getUnscaledPoints__SWIG_0 (btConvexHullShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)(arg1)->getUnscaledPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getUnscaledPoints__SWIG_1 (btConvexHullShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)((btConvexHullShape const *)arg1)->getUnscaledPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getPoints (btConvexHullShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)((btConvexHullShape const *)arg1)->getPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getScaledPoint (btConvexHullShape *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexHullShape const *)arg1)->getScaledPoint(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btConvexHullShape_getNumPoints (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_localGetSupportingVertex (btConvexHullShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexHullShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_localGetSupportingVertexWithoutMargin (btConvexHullShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexHullShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexHullShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btConvexHullShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexHullShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexHullShape_project (btConvexHullShape *larg1, btTransform *larg2, btVector3 *larg3, btScalar *larg4, btScalar *larg5, btVector3 *larg6, btVector3 *larg7) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    ((btConvexHullShape const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btConvexHullShape_getName (btConvexHullShape *larg1) {
  char * lresult = (char *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btConvexHullShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btConvexHullShape_getNumVertices (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btConvexHullShape_getNumEdges (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexHullShape_getEdge (btConvexHullShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexHullShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexHullShape_getVertex (btConvexHullShape *larg1, int larg2, btVector3 *larg3) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexHullShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexHullShape_getNumPlanes (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexHullShape_getPlane (btConvexHullShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexHullShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexHullShape_isInside (btConvexHullShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btConvexHullShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexHullShape_setLocalScaling (btConvexHullShape *larg1, btVector3 *larg2) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexHullShape_calculateSerializeBufferSize (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConvexHullShape_serialize (btConvexHullShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConvexHullShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btConvexHullShape (btConvexHullShape *larg1) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSphereShape *_wrap_new_btSphereShape (btScalar larg1) {
  btSphereShape * lresult = (btSphereShape *)0 ;
  btScalar arg1 ;
  btSphereShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSphereShape *)new btSphereShape(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSphereShape *)0;
  }
}


EXPORT btVector3 *_wrap_btSphereShape_localGetSupportingVertex (btSphereShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btSphereShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btSphereShape_localGetSupportingVertexWithoutMargin (btSphereShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btSphereShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btSphereShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btSphereShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSphereShape_calculateLocalInertia (btSphereShape *larg1, btScalar larg2, btVector3 *larg3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btSphereShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSphereShape_getAabb (btSphereShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btSphereShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSphereShape_getRadius (btSphereShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSphereShape const *)arg1)->getRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSphereShape_setUnscaledRadius (btSphereShape *larg1, btScalar larg2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUnscaledRadius(arg2);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btSphereShape_getName (btSphereShape *larg1) {
  char * lresult = (char *)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btSphereShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btSphereShape_setMargin (btSphereShape *larg1, btScalar larg2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSphereShape_getMargin (btSphereShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSphereShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btSphereShape (btSphereShape *larg1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btMultiSphereShape *_wrap_new_btMultiSphereShape (btVector3 *larg1, btScalar *larg2, int larg3) {
  btMultiSphereShape * lresult = (btMultiSphereShape *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  int arg3 ;
  btMultiSphereShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btMultiSphereShape *)new btMultiSphereShape((btVector3 const *)arg1,(btScalar const *)arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMultiSphereShape *)0;
  }
}


EXPORT void _wrap_btMultiSphereShape_calculateLocalInertia (btMultiSphereShape *larg1, btScalar larg2, btVector3 *larg3) {
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btMultiSphereShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btMultiSphereShape_localGetSupportingVertexWithoutMargin (btMultiSphereShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMultiSphereShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btMultiSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btMultiSphereShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMultiSphereShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btMultiSphereShape_getSphereCount (btMultiSphereShape *larg1) {
  int lresult = (int)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btMultiSphereShape const *)arg1)->getSphereCount();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btMultiSphereShape_getSpherePosition (btMultiSphereShape *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &((btMultiSphereShape const *)arg1)->getSpherePosition(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btMultiSphereShape_getSphereRadius (btMultiSphereShape *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMultiSphereShape const *)arg1)->getSphereRadius(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT char *_wrap_btMultiSphereShape_getName (btMultiSphereShape *larg1) {
  char * lresult = (char *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btMultiSphereShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btMultiSphereShape_calculateSerializeBufferSize (btMultiSphereShape *larg1) {
  int lresult = (int)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btMultiSphereShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btMultiSphereShape_serialize (btMultiSphereShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btMultiSphereShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btMultiSphereShape (btMultiSphereShape *larg1) {
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConcaveShape (btConcaveShape *larg1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConcaveShape_processAllTriangles (btConcaveShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConcaveShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConcaveShape_getMargin (btConcaveShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConcaveShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConcaveShape_setMargin (btConcaveShape *larg1, btScalar larg2) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btStaticPlaneShape *_wrap_new_btStaticPlaneShape (btVector3 *larg1, btScalar larg2) {
  btStaticPlaneShape * lresult = (btStaticPlaneShape *)0 ;
  btVector3 *arg1 = 0 ;
  btScalar arg2 ;
  btStaticPlaneShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btStaticPlaneShape *)new btStaticPlaneShape((btVector3 const &)*arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btStaticPlaneShape *)0;
  }
}


EXPORT void _wrap_delete_btStaticPlaneShape (btStaticPlaneShape *larg1) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_getAabb (btStaticPlaneShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btStaticPlaneShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_processAllTriangles (btStaticPlaneShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btStaticPlaneShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_calculateLocalInertia (btStaticPlaneShape *larg1, btScalar larg2, btVector3 *larg3) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btStaticPlaneShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_setLocalScaling (btStaticPlaneShape *larg1, btVector3 *larg2) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btStaticPlaneShape_getLocalScaling (btStaticPlaneShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btStaticPlaneShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btStaticPlaneShape_getPlaneNormal (btStaticPlaneShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btStaticPlaneShape const *)arg1)->getPlaneNormal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar *_wrap_btStaticPlaneShape_getPlaneConstant (btStaticPlaneShape *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btStaticPlaneShape const *)arg1)->getPlaneConstant();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT char *_wrap_btStaticPlaneShape_getName (btStaticPlaneShape *larg1) {
  char * lresult = (char *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btStaticPlaneShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btStaticPlaneShape_calculateSerializeBufferSize (btStaticPlaneShape *larg1) {
  int lresult = (int)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btStaticPlaneShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btStaticPlaneShape_serialize (btStaticPlaneShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btStaticPlaneShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_getHalfExtentsWithMargin (btBoxShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btBoxShape const *)arg1)->getHalfExtentsWithMargin();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_getHalfExtentsWithoutMargin (btBoxShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btBoxShape const *)arg1)->getHalfExtentsWithoutMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_localGetSupportingVertex (btBoxShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btBoxShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_localGetSupportingVertexWithoutMargin (btBoxShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btBoxShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btBoxShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btBoxShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btBoxShape *_wrap_new_btBoxShape (btVector3 *larg1) {
  btBoxShape * lresult = (btBoxShape *)0 ;
  btVector3 *arg1 = 0 ;
  btBoxShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBoxShape *)new btBoxShape((btVector3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBoxShape *)0;
  }
}


EXPORT void _wrap_btBoxShape_setMargin (btBoxShape *larg1, btScalar larg2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_setLocalScaling (btBoxShape *larg1, btVector3 *larg2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getAabb (btBoxShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_calculateLocalInertia (btBoxShape *larg1, btScalar larg2, btVector3 *larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getPlane (btBoxShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBoxShape_getNumPlanes (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btBoxShape_getNumVertices (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btBoxShape_getNumEdges (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBoxShape_getVertex (btBoxShape *larg1, int larg2, btVector3 *larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getPlaneEquation (btBoxShape *larg1, btVector4 *larg2, int larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector4 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->getPlaneEquation(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getEdge (btBoxShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBoxShape_isInside (btBoxShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btBoxShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btBoxShape_getName (btBoxShape *larg1) {
  char * lresult = (char *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btBoxShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btBoxShape_getNumPreferredPenetrationDirections (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBoxShape_getPreferredPenetrationDirection (btBoxShape *larg1, int larg2, btVector3 *larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btBoxShape (btBoxShape *larg1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCapsuleShape *_wrap_new_btCapsuleShape__SWIG_1 (btScalar larg1, btScalar larg2) {
  btCapsuleShape * lresult = (btCapsuleShape *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCapsuleShape *)new btCapsuleShape(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCapsuleShape *)0;
  }
}


EXPORT void _wrap_btCapsuleShape_calculateLocalInertia (btCapsuleShape *larg1, btScalar larg2, btVector3 *larg3) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCapsuleShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCapsuleShape_localGetSupportingVertexWithoutMargin (btCapsuleShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btCapsuleShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCapsuleShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btCapsuleShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCapsuleShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCapsuleShape_setMargin (btCapsuleShape *larg1, btScalar larg2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCapsuleShape_getAabb (btCapsuleShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCapsuleShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btCapsuleShape_getName (btCapsuleShape *larg1) {
  char * lresult = (char *)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCapsuleShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btCapsuleShape_getUpAxis (btCapsuleShape *larg1) {
  int lresult = (int)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCapsuleShape const *)arg1)->getUpAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btCapsuleShape_getRadius (btCapsuleShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCapsuleShape const *)arg1)->getRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCapsuleShape_getHalfHeight (btCapsuleShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCapsuleShape const *)arg1)->getHalfHeight();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCapsuleShape_setLocalScaling (btCapsuleShape *larg1, btVector3 *larg2) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCapsuleShape_getAnisotropicRollingFrictionDirection (btCapsuleShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btCapsuleShape const *)arg1)->getAnisotropicRollingFrictionDirection();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btCapsuleShape_calculateSerializeBufferSize (btCapsuleShape *larg1) {
  int lresult = (int)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCapsuleShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCapsuleShape_serialize (btCapsuleShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCapsuleShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btCapsuleShape (btCapsuleShape *larg1) {
  btCapsuleShape *arg1 = (btCapsuleShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCapsuleShapeX *_wrap_new_btCapsuleShapeX (btScalar larg1, btScalar larg2) {
  btCapsuleShapeX * lresult = (btCapsuleShapeX *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeX *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCapsuleShapeX *)new btCapsuleShapeX(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCapsuleShapeX *)0;
  }
}


EXPORT char *_wrap_btCapsuleShapeX_getName (btCapsuleShapeX *larg1) {
  char * lresult = (char *)0 ;
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCapsuleShapeX const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btCapsuleShapeX (btCapsuleShapeX *larg1) {
  btCapsuleShapeX *arg1 = (btCapsuleShapeX *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCapsuleShapeZ *_wrap_new_btCapsuleShapeZ (btScalar larg1, btScalar larg2) {
  btCapsuleShapeZ * lresult = (btCapsuleShapeZ *)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btCapsuleShapeZ *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btCapsuleShapeZ *)new btCapsuleShapeZ(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCapsuleShapeZ *)0;
  }
}


EXPORT char *_wrap_btCapsuleShapeZ_getName (btCapsuleShapeZ *larg1) {
  char * lresult = (char *)0 ;
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCapsuleShapeZ const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btCapsuleShapeZ (btCapsuleShapeZ *larg1) {
  btCapsuleShapeZ *arg1 = (btCapsuleShapeZ *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btDynamicsWorld (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDynamicsWorld_stepSimulation__SWIG_0 (btDynamicsWorld *larg1, btScalar larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDynamicsWorld_stepSimulation__SWIG_1 (btDynamicsWorld *larg1, btScalar larg2, int larg3) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDynamicsWorld_stepSimulation__SWIG_2 (btDynamicsWorld *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->stepSimulation(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_debugDrawWorld (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addConstraint__SWIG_0 (btDynamicsWorld *larg1, btTypedConstraint *larg2, int larg3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->addConstraint(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addConstraint__SWIG_1 (btDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeConstraint (btDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addAction (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeAction (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setGravity (btDynamicsWorld *larg1, btVector3 *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btDynamicsWorld_getGravity (btDynamicsWorld *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btDynamicsWorld const *)arg1)->getGravity();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_synchronizeMotionStates (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->synchronizeMotionStates();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addRigidBody__SWIG_0 (btDynamicsWorld *larg1, btRigidBody *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addRigidBody__SWIG_1 (btDynamicsWorld *larg1, btRigidBody *larg2, short larg3, short larg4) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addRigidBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeRigidBody (btDynamicsWorld *larg1, btRigidBody *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setConstraintSolver (btDynamicsWorld *larg1, btConstraintSolver *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConstraintSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolver *_wrap_btDynamicsWorld_getConstraintSolver (btDynamicsWorld *larg1) {
  btConstraintSolver * lresult = (btConstraintSolver *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolver *)(arg1)->getConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolver *)0;
  }
}


EXPORT int _wrap_btDynamicsWorld_getNumConstraints (btDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDynamicsWorld const *)arg1)->getNumConstraints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDynamicsWorld_getConstraint__SWIG_0 (btDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)(arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDynamicsWorld_getConstraint__SWIG_1 (btDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)((btDynamicsWorld const *)arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btDynamicsWorld_getWorldType (btDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_clearForces (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_0 (btDynamicsWorld *larg1, btInternalTickCallback larg2, void *larg3, int larg4) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  bool arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    (arg1)->setInternalTickCallback(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_1 (btDynamicsWorld *larg1, btInternalTickCallback larg2, void *larg3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setInternalTickCallback(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_2 (btDynamicsWorld *larg1, btInternalTickCallback larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInternalTickCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setWorldUserInfo (btDynamicsWorld *larg1, void *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldUserInfo(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btDynamicsWorld_getWorldUserInfo (btDynamicsWorld *larg1) {
  void * lresult = (void *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btDynamicsWorld const *)arg1)->getWorldUserInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT btContactSolverInfo *_wrap_btDynamicsWorld_getSolverInfo (btDynamicsWorld *larg1) {
  btContactSolverInfo * lresult = (btContactSolverInfo *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btContactSolverInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btContactSolverInfo *) &(arg1)->getSolverInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btContactSolverInfo *)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_addVehicle (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeVehicle (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addCharacter (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeCharacter (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btDiscreteDynamicsWorld *_wrap_new_btDiscreteDynamicsWorld (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4) {
  btDiscreteDynamicsWorld * lresult = (btDiscreteDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btDiscreteDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btDiscreteDynamicsWorld *)new btDiscreteDynamicsWorld(arg1,arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDiscreteDynamicsWorld *)0;
  }
}


EXPORT void _wrap_delete_btDiscreteDynamicsWorld (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_stepSimulation3 (btDiscreteDynamicsWorld *larg1, btScalar larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_stepSimulation2 (btDiscreteDynamicsWorld *larg1, btScalar larg2, int larg3) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_stepSimulation1 (btDiscreteDynamicsWorld *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->stepSimulation(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_synchronizeMotionStates (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->synchronizeMotionStates();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_synchronizeSingleMotionState (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->synchronizeSingleMotionState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_0 (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2, int larg3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->addConstraint(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_1 (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeConstraint (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addAction (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeAction (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_0 (btDiscreteDynamicsWorld *larg1) {
  btSimulationIslandManager * lresult = (btSimulationIslandManager *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSimulationIslandManager *)(arg1)->getSimulationIslandManager();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimulationIslandManager *)0;
  }
}


EXPORT btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_1 (btDiscreteDynamicsWorld *larg1) {
  btSimulationIslandManager * lresult = (btSimulationIslandManager *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSimulationIslandManager *)((btDiscreteDynamicsWorld const *)arg1)->getSimulationIslandManager();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimulationIslandManager *)0;
  }
}


EXPORT btCollisionWorld *_wrap_btDiscreteDynamicsWorld_getCollisionWorld (btDiscreteDynamicsWorld *larg1) {
  btCollisionWorld * lresult = (btCollisionWorld *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionWorld *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionWorld *)(arg1)->getCollisionWorld();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionWorld *)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setGravity (btDiscreteDynamicsWorld *larg1, btVector3 *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btDiscreteDynamicsWorld_getGravity (btDiscreteDynamicsWorld *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btDiscreteDynamicsWorld const *)arg1)->getGravity();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_0 (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2, short larg3, short larg4) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addCollisionObject(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_1 (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2, short larg3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addCollisionObject(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_2 (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addRigidBody (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addRigidBodyWithMask (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2, short larg3, short larg4) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addRigidBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeRigidBody (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeCollisionObject (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_debugDrawConstraint (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->debugDrawConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_debugDrawWorld (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setConstraintSolver (btDiscreteDynamicsWorld *larg1, btConstraintSolver *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConstraintSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolver *_wrap_btDiscreteDynamicsWorld_getConstraintSolver (btDiscreteDynamicsWorld *larg1) {
  btConstraintSolver * lresult = (btConstraintSolver *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolver *)(arg1)->getConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolver *)0;
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getNumConstraints (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDiscreteDynamicsWorld const *)arg1)->getNumConstraints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_0 (btDiscreteDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)(arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_1 (btDiscreteDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)((btDiscreteDynamicsWorld const *)arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btDiscreteDynamicsWorld_getWorldType (btDiscreteDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btDiscreteDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_clearForces (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_applyGravity (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->applyGravity();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setNumTasks (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNumTasks(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_updateVehicles (btDiscreteDynamicsWorld *larg1, btScalar larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateVehicles(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addVehicle (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeVehicle (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCharacter (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeCharacter (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setSynchronizeAllMotionStates (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setSynchronizeAllMotionStates(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getSynchronizeAllMotionStates (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getSynchronizeAllMotionStates();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setApplySpeculativeContactRestitution(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getApplySpeculativeContactRestitution();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_serialize (btDiscreteDynamicsWorld *larg1, btSerializer *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serialize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setLatencyMotionStateInterpolation (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setLatencyMotionStateInterpolation(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getLatencyMotionStateInterpolation (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getLatencyMotionStateInterpolation();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btSimpleDynamicsWorld *_wrap_new_btSimpleDynamicsWorld (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4) {
  btSimpleDynamicsWorld * lresult = (btSimpleDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btSimpleDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btSimpleDynamicsWorld *)new btSimpleDynamicsWorld(arg1,arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimpleDynamicsWorld *)0;
  }
}


EXPORT void _wrap_delete_btSimpleDynamicsWorld (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSimpleDynamicsWorld_stepSimulation__SWIG_0 (btSimpleDynamicsWorld *larg1, btScalar larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSimpleDynamicsWorld_stepSimulation__SWIG_1 (btSimpleDynamicsWorld *larg1, btScalar larg2, int larg3) {
  int lresult = (int)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSimpleDynamicsWorld_stepSimulation__SWIG_2 (btSimpleDynamicsWorld *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->stepSimulation(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_setGravity (btSimpleDynamicsWorld *larg1, btVector3 *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSimpleDynamicsWorld_getGravity (btSimpleDynamicsWorld *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btSimpleDynamicsWorld const *)arg1)->getGravity();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_addRigidBody__SWIG_0 (btSimpleDynamicsWorld *larg1, btRigidBody *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_addRigidBody__SWIG_1 (btSimpleDynamicsWorld *larg1, btRigidBody *larg2, short larg3, short larg4) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addRigidBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_removeRigidBody (btSimpleDynamicsWorld *larg1, btRigidBody *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_debugDrawWorld (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_addAction (btSimpleDynamicsWorld *larg1, btActionInterface *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_removeAction (btSimpleDynamicsWorld *larg1, btActionInterface *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_removeCollisionObject (btSimpleDynamicsWorld *larg1, btCollisionObject *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_updateAabbs (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateAabbs();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_synchronizeMotionStates (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->synchronizeMotionStates();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_setConstraintSolver (btSimpleDynamicsWorld *larg1, btConstraintSolver *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConstraintSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolver *_wrap_btSimpleDynamicsWorld_getConstraintSolver (btSimpleDynamicsWorld *larg1) {
  btConstraintSolver * lresult = (btConstraintSolver *)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolver *)(arg1)->getConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolver *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btSimpleDynamicsWorld_getWorldType (btSimpleDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btSimpleDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_clearForces (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_new_btRigidBody_from_btRigidBodyConstructionInfo (btRigidBody::btRigidBodyConstructionInfo *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btRigidBody::btRigidBodyConstructionInfo *arg1 = 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)new btRigidBody((btRigidBody::btRigidBodyConstructionInfo const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_new_btRigidBody_backward_compatible (btScalar larg1, btMotionState *larg2, btCollisionShape *larg3, btVector3 *larg4) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_new_btRigidBody (btScalar larg1, btMotionState *larg2, btCollisionShape *larg3) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT void _wrap_delete_btRigidBody (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_proceedToTransform (btRigidBody *larg1, btTransform *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->proceedToTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btRigidBody_upcast__SWIG_0 (btCollisionObject *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)btRigidBody::upcast((btCollisionObject const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btRigidBody_upcast__SWIG_1 (btCollisionObject *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)btRigidBody::upcast(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT void _wrap_btRigidBody_predictIntegratedTransform (btRigidBody *larg1, btScalar larg2, btTransform *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->predictIntegratedTransform(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_saveKinematicState (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->saveKinematicState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyGravity (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->applyGravity();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setGravity (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getGravity (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getGravity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setDamping (btRigidBody *larg1, btScalar larg2, btScalar larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setDamping(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBody_getLinearDamping (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getLinearDamping();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_getAngularDamping (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getAngularDamping();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_getLinearSleepingThreshold (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getLinearSleepingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_getAngularSleepingThreshold (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getAngularSleepingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBody_applyDamping (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyDamping(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_0 (btRigidBody *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)((btRigidBody const *)arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_1 (btRigidBody *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)(arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT void _wrap_btRigidBody_setMassProps (btRigidBody *larg1, btScalar larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMassProps(arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getLinearFactor (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setLinearFactor (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearFactor((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBody_getInvMass (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getInvMass();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btRigidBody_getInvInertiaTensorWorld (btRigidBody *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *) &((btRigidBody const *)arg1)->getInvInertiaTensorWorld();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_integrateVelocities (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->integrateVelocities(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setCenterOfMassTransform (btRigidBody *larg1, btTransform *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCenterOfMassTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyCentralForce (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyCentralForce((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getTotalForce (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalForce();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getTotalTorque (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalTorque();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getInvInertiaDiagLocal (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getInvInertiaDiagLocal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setInvInertiaDiagLocal (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInvInertiaDiagLocal((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setSleepingThresholds (btRigidBody *larg1, btScalar larg2, btScalar larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSleepingThresholds(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyTorque (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyTorque((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyForce (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->applyForce((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyCentralImpulse (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyCentralImpulse((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyTorqueImpulse (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyTorqueImpulse((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyImpulse (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->applyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_clearForces (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_updateInertiaTensor (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateInertiaTensor();
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getCenterOfMassPosition (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getCenterOfMassPosition();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btRigidBody_getOrientation (btRigidBody *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btRigidBody const *)arg1)->getOrientation();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btTransform *_wrap_btRigidBody_getCenterOfMassTransform (btRigidBody *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btRigidBody const *)arg1)->getCenterOfMassTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getLinearVelocity (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getAngularVelocity (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setLinearVelocity (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setAngularVelocity (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getVelocityInLocalPoint (btRigidBody *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btRigidBody const *)arg1)->getVelocityInLocalPoint((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_translate (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->translate((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_getAabb (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btRigidBody const *)arg1)->getAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBody_computeImpulseDenominator (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->computeImpulseDenominator((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_computeAngularImpulseDenominator (btRigidBody *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->computeAngularImpulseDenominator((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBody_updateDeactivation (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateDeactivation(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_wantsSleeping (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->wantsSleeping();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_0 (btRigidBody *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)((btRigidBody const *)arg1)->getBroadphaseProxy();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_1 (btRigidBody *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)(arg1)->getBroadphaseProxy();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btRigidBody_setNewBroadphaseProxy (btRigidBody *larg1, btBroadphaseProxy *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNewBroadphaseProxy(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btMotionState *_wrap_btRigidBody_getMotionState__SWIG_0 (btRigidBody *larg1) {
  btMotionState * lresult = (btMotionState *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMotionState *)(arg1)->getMotionState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMotionState *)0;
  }
}


EXPORT btMotionState *_wrap_btRigidBody_getMotionState__SWIG_1 (btRigidBody *larg1) {
  btMotionState * lresult = (btMotionState *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMotionState *)((btRigidBody const *)arg1)->getMotionState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMotionState *)0;
  }
}


EXPORT void _wrap_btRigidBody_setMotionState (btRigidBody *larg1, btMotionState *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMotionState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_m_contactSolverType_set (btRigidBody *larg1, int larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_contactSolverType = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_m_contactSolverType_get (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_contactSolverType);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_m_frictionSolverType_set (btRigidBody *larg1, int larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_frictionSolverType = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_m_frictionSolverType_get (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_frictionSolverType);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_setAngularFactor__SWIG_0 (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularFactor((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setAngularFactor__SWIG_1 (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularFactor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getAngularFactor (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btRigidBody_isInWorld (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btRigidBody const *)arg1)->isInWorld();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRigidBody_checkCollideWithOverride (btRigidBody *larg1, btCollisionObject *larg2) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btRigidBody const *)arg1)->checkCollideWithOverride((btCollisionObject const *)arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_addConstraintRef (btRigidBody *larg1, btTypedConstraint *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addConstraintRef(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_removeConstraintRef (btRigidBody *larg1, btTypedConstraint *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeConstraintRef(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btTypedConstraint *_wrap_btRigidBody_getConstraintRef (btRigidBody *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)(arg1)->getConstraintRef(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT int _wrap_btRigidBody_getNumConstraintRefs (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRigidBody const *)arg1)->getNumConstraintRefs();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_setFlags (btRigidBody *larg1, int larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_getFlags (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRigidBody const *)arg1)->getFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_computeGyroscopicForce (btRigidBody *larg1, btScalar larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btRigidBody const *)arg1)->computeGyroscopicForce(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btRigidBody_calculateSerializeBufferSize (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRigidBody const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btRigidBody_serialize (btRigidBody *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btRigidBody const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btRigidBody_serializeSingleObject (btRigidBody *larg1, btSerializer *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btRigidBody const *)arg1)->serializeSingleObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_mass_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_mass = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_mass_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_mass);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_motionState_set (btRigidBodyConstructionInfo *larg1, btMotionState *larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_motionState = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btMotionState *_wrap_btRigidBodyConstructionInfo_m_motionState_get (btRigidBodyConstructionInfo *larg1) {
  btMotionState * lresult = (btMotionState *)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btMotionState *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMotionState *) ((arg1)->m_motionState);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMotionState *)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_startWorldTransform_set (btRigidBodyConstructionInfo *larg1, btTransform *larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_startWorldTransform = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btRigidBodyConstructionInfo_m_startWorldTransform_get (btRigidBodyConstructionInfo *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)& ((arg1)->m_startWorldTransform);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_collisionShape_set (btRigidBodyConstructionInfo *larg1, btCollisionShape *larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_collisionShape = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btCollisionShape *_wrap_btRigidBodyConstructionInfo_m_collisionShape_get (btRigidBodyConstructionInfo *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *) ((arg1)->m_collisionShape);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_localInertia_set (btRigidBodyConstructionInfo *larg1, btVector3 *larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_localInertia = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBodyConstructionInfo_m_localInertia_get (btRigidBodyConstructionInfo *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_localInertia);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_linearDamping_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_linearDamping = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_linearDamping_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_linearDamping);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_angularDamping_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_angularDamping = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_angularDamping_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_angularDamping);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_friction_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_friction = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_friction_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_friction);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_rollingFriction_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_rollingFriction = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_rollingFriction_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_rollingFriction);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_restitution_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_restitution = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_restitution_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_restitution);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_linearSleepingThreshold_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_linearSleepingThreshold = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_linearSleepingThreshold_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_linearSleepingThreshold);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_angularSleepingThreshold_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_angularSleepingThreshold = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_angularSleepingThreshold_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_angularSleepingThreshold);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_additionalDamping_set (btRigidBodyConstructionInfo *larg1, int larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_additionalDamping = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBodyConstructionInfo_m_additionalDamping_get (btRigidBodyConstructionInfo *larg1) {
  int lresult = (int)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_additionalDamping);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_additionalDampingFactor_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_additionalDampingFactor = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_additionalDampingFactor_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_additionalDampingFactor);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_additionalLinearDampingThresholdSqr_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_additionalLinearDampingThresholdSqr = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_additionalLinearDampingThresholdSqr_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_additionalLinearDampingThresholdSqr);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_additionalAngularDampingThresholdSqr_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_additionalAngularDampingThresholdSqr = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_additionalAngularDampingThresholdSqr_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_additionalAngularDampingThresholdSqr);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBodyConstructionInfo_m_additionalAngularDampingFactor_set (btRigidBodyConstructionInfo *larg1, btScalar larg2) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_additionalAngularDampingFactor = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBodyConstructionInfo_m_additionalAngularDampingFactor_get (btRigidBodyConstructionInfo *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_additionalAngularDampingFactor);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btRigidBodyConstructionInfo *_wrap_new_btRigidBodyConstructionInfo_4 (btScalar larg1, btMotionState *larg2, btCollisionShape *larg3, btVector3 *larg4) {
  btRigidBodyConstructionInfo * lresult = (btRigidBodyConstructionInfo *)0 ;
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  btRigidBodyConstructionInfo *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btRigidBodyConstructionInfo *)new btRigidBodyConstructionInfo(arg1,arg2,arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBodyConstructionInfo *)0;
  }
}


EXPORT btRigidBodyConstructionInfo *_wrap_new_btRigidBodyConstructionInfo_3 (btScalar larg1, btMotionState *larg2, btCollisionShape *larg3) {
  btRigidBodyConstructionInfo * lresult = (btRigidBodyConstructionInfo *)0 ;
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btRigidBodyConstructionInfo *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btRigidBodyConstructionInfo *)new btRigidBodyConstructionInfo(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBodyConstructionInfo *)0;
  }
}


EXPORT void _wrap_delete_btRigidBodyConstructionInfo (btRigidBodyConstructionInfo *larg1) {
  btRigidBodyConstructionInfo *arg1 = (btRigidBodyConstructionInfo *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConstraintSolver (btConstraintSolver *larg1) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConstraintSolver_prepareSolve (btConstraintSolver *larg1, int larg2, int larg3) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->prepareSolve(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConstraintSolver_solveGroup (btConstraintSolver *larg1, btCollisionObject **larg2, int larg3, btPersistentManifold **larg4, int larg5, btTypedConstraint **larg6, int larg7, btContactSolverInfo *larg8, btIDebugDraw *larg9, btDispatcher *larg10) {
  btScalar lresult = (btScalar)0 ;
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btCollisionObject **arg2 = (btCollisionObject **) 0 ;
  int arg3 ;
  btPersistentManifold **arg4 = (btPersistentManifold **) 0 ;
  int arg5 ;
  btTypedConstraint **arg6 = (btTypedConstraint **) 0 ;
  int arg7 ;
  btContactSolverInfo *arg8 = 0 ;
  btIDebugDraw *arg9 = (btIDebugDraw *) 0 ;
  btDispatcher *arg10 = (btDispatcher *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    result = (btScalar)(arg1)->solveGroup(arg2,arg3,arg4,arg5,arg6,arg7,(btContactSolverInfo const &)*arg8,arg9,arg10);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConstraintSolver_allSolved (btConstraintSolver *larg1, btContactSolverInfo *larg2, btIDebugDraw *larg3) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btContactSolverInfo *arg2 = 0 ;
  btIDebugDraw *arg3 = (btIDebugDraw *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->allSolved((btContactSolverInfo const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConstraintSolver_reset (btConstraintSolver *larg1) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->reset();
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolverType _wrap_btConstraintSolver_getSolverType (btConstraintSolver *larg1) {
  btConstraintSolverType lresult = (btConstraintSolverType)0 ;
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btConstraintSolverType result;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolverType)((btConstraintSolver const *)arg1)->getSolverType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolverType)0;
  }
}


EXPORT void _wrap_delete_btTypedConstraint (btTypedConstraint *larg1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getFixedBody () {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btRigidBody *result = 0 ;
  
  try {
    result = (btRigidBody *) &btTypedConstraint::getFixedBody();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT int _wrap_btTypedConstraint_getOverrideNumSolverIterations (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getOverrideNumSolverIterations();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setOverrideNumSolverIterations (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOverrideNumSolverIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_buildJacobian (btTypedConstraint *larg1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_setupSolverConstraint (btTypedConstraint *larg1, btConstraintArray *larg2, int larg3, int larg4, btScalar larg5) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_getInfo1 (btTypedConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_getInfo2 (btTypedConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_internalSetAppliedImpulse (btTypedConstraint *larg1, btScalar larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->internalSetAppliedImpulse(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_internalGetAppliedImpulse (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->internalGetAppliedImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getBreakingImpulseThreshold (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getBreakingImpulseThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setBreakingImpulseThreshold (btTypedConstraint *larg1, btScalar larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBreakingImpulseThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTypedConstraint_isEnabled (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btTypedConstraint const *)arg1)->isEnabled();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setEnabled (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setEnabled(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_solveConstraintObsolete (btTypedConstraint *larg1, btSolverBody *larg2, btSolverBody *larg3, btScalar larg4) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_0 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_0 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_1 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_1 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT int _wrap_btTypedConstraint_getUserConstraintType (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getUserConstraintType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setUserConstraintType (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintType(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_setUserConstraintId (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintId(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTypedConstraint_getUserConstraintId (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getUserConstraintId();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setUserConstraintPtr (btTypedConstraint *larg1, void *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintPtr(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btTypedConstraint_getUserConstraintPtr (btTypedConstraint *larg1) {
  void * lresult = (void *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)(arg1)->getUserConstraintPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setJointFeedback (btTypedConstraint *larg1, btJointFeedback *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setJointFeedback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_0 (btTypedConstraint *larg1) {
  btJointFeedback * lresult = (btJointFeedback *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btJointFeedback *)((btTypedConstraint const *)arg1)->getJointFeedback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJointFeedback *)0;
  }
}


EXPORT btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_1 (btTypedConstraint *larg1) {
  btJointFeedback * lresult = (btJointFeedback *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btJointFeedback *)(arg1)->getJointFeedback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJointFeedback *)0;
  }
}


EXPORT int _wrap_btTypedConstraint_getUid (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getUid();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTypedConstraint_needsFeedback (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btTypedConstraint const *)arg1)->needsFeedback();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_enableFeedback (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->enableFeedback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getAppliedImpulse (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getAppliedImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btTypedConstraintType _wrap_btTypedConstraint_getConstraintType (btTypedConstraint *larg1) {
  btTypedConstraintType lresult = (btTypedConstraintType)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraintType result;
  
  arg1 = larg1;
  try {
    result = (btTypedConstraintType)((btTypedConstraint const *)arg1)->getConstraintType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraintType)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setDbgDrawSize (btTypedConstraint *larg1, btScalar larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDbgDrawSize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getDbgDrawSize (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDbgDrawSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setParam__SWIG_0 (btTypedConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_setParam__SWIG_1 (btTypedConstraint *larg1, int larg2, btScalar larg3) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getParam__SWIG_0 (btTypedConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getParam__SWIG_1 (btTypedConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btTypedConstraint_calculateSerializeBufferSize (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btTypedConstraint_serialize (btTypedConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btTypedConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btScalar _wrap_btAdjustAngleToLimits (btScalar larg1, btScalar larg2, btScalar larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btAdjustAngleToLimits(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btAngularLimit *_wrap_new_btAngularLimit () {
  btAngularLimit * lresult = (btAngularLimit *)0 ;
  btAngularLimit *result = 0 ;
  
  try {
    result = (btAngularLimit *)new btAngularLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAngularLimit *)0;
  }
}


EXPORT void _wrap_btAngularLimit_btAngularLimit_set_5 (btAngularLimit *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->set(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_btAngularLimit_set_4 (btAngularLimit *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->set(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_btAngularLimit_set_3 (btAngularLimit *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->set(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_btAngularLimit_set_2 (btAngularLimit *larg1, btScalar larg2, btScalar larg3) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->set(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_test (btAngularLimit *larg1, btScalar larg2) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->test(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btAngularLimit_getSoftness (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getSoftness();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getBiasFactor (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getBiasFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getRelaxationFactor (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getRelaxationFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getCorrection (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getCorrection();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getSign (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getSign();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getHalfRange (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getHalfRange();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btAngularLimit_isLimit (btAngularLimit *larg1) {
  int lresult = (int)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btAngularLimit const *)arg1)->isLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btAngularLimit_fit (btAngularLimit *larg1, btScalar *larg2) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btAngularLimit const *)arg1)->fit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btAngularLimit_getError (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getError();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getLow (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getLow();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getHigh (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getHigh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btAngularLimit (btAngularLimit *larg1) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_m_useSolveConstraintObsolete_set (btPoint2PointConstraint *larg1, int larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_useSolveConstraintObsolete = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPoint2PointConstraint_m_useSolveConstraintObsolete_get (btPoint2PointConstraint *larg1) {
  int lresult = (int)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_useSolveConstraintObsolete);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPoint2PointConstraint_m_setting_set (btPoint2PointConstraint *larg1, btConstraintSetting *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btConstraintSetting *arg2 = (btConstraintSetting *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_setting = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSetting *_wrap_btPoint2PointConstraint_m_setting_get (btPoint2PointConstraint *larg1) {
  btConstraintSetting * lresult = (btConstraintSetting *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btConstraintSetting *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSetting *)& ((arg1)->m_setting);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSetting *)0;
  }
}


EXPORT btPoint2PointConstraint *_wrap_new_btPoint2PointConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4) {
  btPoint2PointConstraint * lresult = (btPoint2PointConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btPoint2PointConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btPoint2PointConstraint *)new btPoint2PointConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoint2PointConstraint *)0;
  }
}


EXPORT btPoint2PointConstraint *_wrap_new_btPoint2PointConstraint__SWIG_1 (btRigidBody *larg1, btVector3 *larg2) {
  btPoint2PointConstraint * lresult = (btPoint2PointConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btPoint2PointConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPoint2PointConstraint *)new btPoint2PointConstraint(*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoint2PointConstraint *)0;
  }
}


EXPORT void _wrap_btPoint2PointConstraint_buildJacobian (btPoint2PointConstraint *larg1) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo1 (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo1NonVirtual (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo2 (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo2NonVirtual (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_updateRHS (btPoint2PointConstraint *larg1, btScalar larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setPivotA (btPoint2PointConstraint *larg1, btVector3 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPivotA((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setPivotB (btPoint2PointConstraint *larg1, btVector3 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPivotB((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btPoint2PointConstraint_getPivotInA (btPoint2PointConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btPoint2PointConstraint const *)arg1)->getPivotInA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btPoint2PointConstraint_getPivotInB (btPoint2PointConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btPoint2PointConstraint const *)arg1)->getPivotInB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setParam__SWIG_0 (btPoint2PointConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setParam__SWIG_1 (btPoint2PointConstraint *larg1, int larg2, btScalar larg3) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btPoint2PointConstraint_getParam__SWIG_0 (btPoint2PointConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btPoint2PointConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btPoint2PointConstraint_getParam__SWIG_1 (btPoint2PointConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btPoint2PointConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btPoint2PointConstraint_calculateSerializeBufferSize (btPoint2PointConstraint *larg1) {
  int lresult = (int)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPoint2PointConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btPoint2PointConstraint_serialize (btPoint2PointConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btPoint2PointConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btPoint2PointConstraint (btPoint2PointConstraint *larg1) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6, int larg7) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  bool arg7 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = (bool)larg7;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_1 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_2 (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool arg4 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_3 (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_4 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_5 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_6 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_7 (btRigidBody *larg1, btTransform *larg2) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT void _wrap_btHingeConstraint_buildJacobian (btHingeConstraint *larg1) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo1 (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo1NonVirtual (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2 (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2NonVirtual (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2Internal (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2Internal(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2InternalUsingFrameOffset (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2InternalUsingFrameOffset(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_updateRHS (btHingeConstraint *larg1, btScalar larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyA__SWIG_0 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btHingeConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyB__SWIG_0 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btHingeConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyA__SWIG_1 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyB__SWIG_1 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getFrameOffsetA (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getFrameOffsetB (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btHingeConstraint_setFrames (btHingeConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setAngularOnly (btHingeConstraint *larg1, int larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setAngularOnly(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_enableAngularMotor (btHingeConstraint *larg1, int larg2, btScalar larg3, btScalar larg4) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->enableAngularMotor(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_enableMotor (btHingeConstraint *larg1, int larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->enableMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setMaxMotorImpulse (btHingeConstraint *larg1, btScalar larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxMotorImpulse(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setMotorTarget__SWIG_0 (btHingeConstraint *larg1, btQuaternion *larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMotorTarget((btQuaternion const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setMotorTarget__SWIG_1 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMotorTarget(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_0 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_1 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_2 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setLimit(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_3 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setAxis (btHingeConstraint *larg1, btVector3 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAxis(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getLowerLimit (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getLowerLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getUpperLimit (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getUpperLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getHingeAngle__SWIG_0 (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getHingeAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getHingeAngle__SWIG_1 (btHingeConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)(arg1)->getHingeAngle((btTransform const &)*arg2,(btTransform const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btHingeConstraint_testLimit (btHingeConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->testLimit((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getAFrame__SWIG_0 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btHingeConstraint const *)arg1)->getAFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getBFrame__SWIG_0 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btHingeConstraint const *)arg1)->getBFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getAFrame__SWIG_1 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getAFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getBFrame__SWIG_1 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getBFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getSolveLimit (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getSolveLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getLimitSign (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLimitSign();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getAngularOnly (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getAngularOnly();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getEnableAngularMotor (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getEnableAngularMotor();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getMotorTargetVelosity (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMotorTargetVelosity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getMaxMotorImpulse (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMaxMotorImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getUseFrameOffset (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseFrameOffset();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btHingeConstraint_setUseFrameOffset (btHingeConstraint *larg1, int larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setUseFrameOffset(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setParam__SWIG_0 (btHingeConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setParam__SWIG_1 (btHingeConstraint *larg1, int larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getParam__SWIG_0 (btHingeConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getParam__SWIG_1 (btHingeConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btHingeConstraint_calculateSerializeBufferSize (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btHingeConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btHingeConstraint_serialize (btHingeConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btHingeConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btHingeConstraint (btHingeConstraint *larg1) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConeTwistConstraint *_wrap_new_btConeTwistConstraint_2 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4) {
  btConeTwistConstraint * lresult = (btConeTwistConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btConeTwistConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConeTwistConstraint *)0;
  }
}


EXPORT btConeTwistConstraint *_wrap_new_btConeTwistConstraint (btRigidBody *larg1, btTransform *larg2) {
  btConeTwistConstraint * lresult = (btConeTwistConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btConeTwistConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,(btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConeTwistConstraint *)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_buildJacobian (btConeTwistConstraint *larg1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo1 (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo1NonVirtual (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo2 (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo2NonVirtual (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btMatrix3x3 *larg5, btMatrix3x3 *larg6) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  btMatrix3x3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btMatrix3x3 const &)*arg5,(btMatrix3x3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_solveConstraintObsolete (btConeTwistConstraint *larg1, btSolverBody *larg2, btSolverBody *larg3, btScalar larg4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_updateRHS (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyA (btConeTwistConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyB (btConeTwistConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setAngularOnly (btConeTwistConstraint *larg1, int larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setAngularOnly(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_0 (btConeTwistConstraint *larg1, int larg2, btScalar larg3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_1 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6, btScalar larg7) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6,arg7);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_2 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_3 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_4 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setLimit(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getAFrame (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getAFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getBFrame (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getBFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_getSolveTwistLimit (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getSolveTwistLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_getSolveSwingLimit (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getSolveSwingLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getTwistLimitSign (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTwistLimitSign();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_calcAngleInfo (btConeTwistConstraint *larg1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->calcAngleInfo();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_calcAngleInfo2 (btConeTwistConstraint *larg1, btTransform *larg2, btTransform *larg3, btMatrix3x3 *larg4, btMatrix3x3 *larg5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btMatrix3x3 *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->calcAngleInfo2((btTransform const &)*arg2,(btTransform const &)*arg3,(btMatrix3x3 const &)*arg4,(btMatrix3x3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getSwingSpan1 (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSwingSpan1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getSwingSpan2 (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSwingSpan2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getTwistSpan (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTwistSpan();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getTwistAngle (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTwistAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_isPastSwingLimit (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->isPastSwingLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setDamping (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDamping(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_enableMotor (btConeTwistConstraint *larg1, int larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->enableMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMaxMotorImpulse (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxMotorImpulse(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMaxMotorImpulseNormalized (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxMotorImpulseNormalized(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getFixThresh (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getFixThresh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setFixThresh (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFixThresh(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMotorTarget (btConeTwistConstraint *larg1, btQuaternion *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMotorTarget((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMotorTargetInConstraintSpace (btConeTwistConstraint *larg1, btQuaternion *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMotorTargetInConstraintSpace((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConeTwistConstraint_GetPointForAngle (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btConeTwistConstraint const *)arg1)->GetPointForAngle(arg2,arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setParam__SWIG_0 (btConeTwistConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setParam__SWIG_1 (btConeTwistConstraint *larg1, int larg2, btScalar larg3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setFrames (btConeTwistConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getFrameOffsetA (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getFrameOffsetB (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getParam__SWIG_0 (btConeTwistConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getParam__SWIG_1 (btConeTwistConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_calculateSerializeBufferSize (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConeTwistConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConeTwistConstraint_serialize (btConeTwistConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConeTwistConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btConeTwistConstraint (btConeTwistConstraint *larg1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_loLimit_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_loLimit = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_loLimit_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_loLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_hiLimit_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_hiLimit = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_hiLimit_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_hiLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_targetVelocity_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_targetVelocity = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_targetVelocity_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_targetVelocity);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_maxMotorForce_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_maxMotorForce = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_maxMotorForce_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_maxMotorForce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_maxLimitForce_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_maxLimitForce = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_maxLimitForce_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_maxLimitForce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_damping_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_damping = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_damping_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_damping);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_limitSoftness_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_limitSoftness = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_limitSoftness_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_limitSoftness);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_normalCFM_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_normalCFM = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_normalCFM_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_normalCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_stopERP_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopERP = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_stopERP_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_stopERP);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_stopCFM_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopCFM = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_stopCFM_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_stopCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_bounce_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_bounce = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_bounce_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_bounce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_enableMotor_set (btRotationalLimitMotor *larg1, int larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_enableMotor = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRotationalLimitMotor_m_enableMotor_get (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_enableMotor);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_currentLimitError_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLimitError = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_currentLimitError_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_currentLimitError);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_currentPosition_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentPosition = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_currentPosition_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_currentPosition);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_currentLimit_set (btRotationalLimitMotor *larg1, int larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLimit = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRotationalLimitMotor_m_currentLimit_get (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_currentLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_accumulatedImpulse_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_accumulatedImpulse = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_accumulatedImpulse_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_accumulatedImpulse);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_0 () {
  btRotationalLimitMotor * lresult = (btRotationalLimitMotor *)0 ;
  btRotationalLimitMotor *result = 0 ;
  
  try {
    result = (btRotationalLimitMotor *)new btRotationalLimitMotor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRotationalLimitMotor *)0;
  }
}


EXPORT btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_1 (btRotationalLimitMotor *larg1) {
  btRotationalLimitMotor * lresult = (btRotationalLimitMotor *)0 ;
  btRotationalLimitMotor *arg1 = 0 ;
  btRotationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRotationalLimitMotor *)new btRotationalLimitMotor((btRotationalLimitMotor const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRotationalLimitMotor *)0;
  }
}


EXPORT int _wrap_btRotationalLimitMotor_isLimited (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->isLimited();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRotationalLimitMotor_needApplyTorques (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->needApplyTorques();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRotationalLimitMotor_testLimitValue (btRotationalLimitMotor *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->testLimitValue(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_solveAngularLimits (btRotationalLimitMotor *larg1, btScalar larg2, btVector3 *larg3, btScalar larg4, btRigidBody *larg5, btRigidBody *larg6) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btRigidBody *arg5 = (btRigidBody *) 0 ;
  btRigidBody *arg6 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (btScalar)(arg1)->solveAngularLimits(arg2,*arg3,arg4,arg5,arg6);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btRotationalLimitMotor (btRotationalLimitMotor *larg1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_lowerLimit_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_lowerLimit = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_lowerLimit_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_lowerLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_upperLimit_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_upperLimit = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_upperLimit_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_upperLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_accumulatedImpulse_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_accumulatedImpulse = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_accumulatedImpulse_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_accumulatedImpulse);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_limitSoftness_set (btTranslationalLimitMotor *larg1, btScalar larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_limitSoftness = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_m_limitSoftness_get (btTranslationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_limitSoftness);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_damping_set (btTranslationalLimitMotor *larg1, btScalar larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_damping = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_m_damping_get (btTranslationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_damping);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_restitution_set (btTranslationalLimitMotor *larg1, btScalar larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_restitution = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_m_restitution_get (btTranslationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_restitution);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_normalCFM_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_normalCFM = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_normalCFM_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_normalCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_stopERP_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopERP = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_stopERP_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_stopERP);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_stopCFM_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopCFM = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_stopCFM_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_stopCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_enableMotor_set (btTranslationalLimitMotor *larg1, bool *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      bool *b = (bool *) arg1->m_enableMotor;
      for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((bool *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT bool *_wrap_btTranslationalLimitMotor_m_enableMotor_get (btTranslationalLimitMotor *larg1) {
  bool * lresult = (bool *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (bool *)(bool *) ((arg1)->m_enableMotor);
    lresult = result;
    return lresult;
  } catch (...) {
    return (bool *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_targetVelocity_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_targetVelocity = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_targetVelocity_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_targetVelocity);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_maxMotorForce_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_maxMotorForce = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_maxMotorForce_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_maxMotorForce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_currentLimitError_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLimitError = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_currentLimitError_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_currentLimitError);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_currentLinearDiff_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLinearDiff = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_currentLinearDiff_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_currentLinearDiff);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_currentLimit_set (btTranslationalLimitMotor *larg1, int *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      int *b = (int *) arg1->m_currentLimit;
      for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((int *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT int *_wrap_btTranslationalLimitMotor_m_currentLimit_get (btTranslationalLimitMotor *larg1) {
  int * lresult = (int *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (int *)(int *) ((arg1)->m_currentLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int *)0;
  }
}


EXPORT btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_0 () {
  btTranslationalLimitMotor * lresult = (btTranslationalLimitMotor *)0 ;
  btTranslationalLimitMotor *result = 0 ;
  
  try {
    result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTranslationalLimitMotor *)0;
  }
}


EXPORT btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_1 (btTranslationalLimitMotor *larg1) {
  btTranslationalLimitMotor * lresult = (btTranslationalLimitMotor *)0 ;
  btTranslationalLimitMotor *arg1 = 0 ;
  btTranslationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor((btTranslationalLimitMotor const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTranslationalLimitMotor *)0;
  }
}


EXPORT int _wrap_btTranslationalLimitMotor_isLimited (btTranslationalLimitMotor *larg1, int larg2) {
  int lresult = (int)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->isLimited(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTranslationalLimitMotor_needApplyForce (btTranslationalLimitMotor *larg1, int larg2) {
  int lresult = (int)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->needApplyForce(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTranslationalLimitMotor_testLimitValue (btTranslationalLimitMotor *larg1, int larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->testLimitValue(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_solveLinearAxis (btTranslationalLimitMotor *larg1, btScalar larg2, btScalar larg3, btRigidBody *larg4, btVector3 *larg5, btRigidBody *larg6, btVector3 *larg7, int larg8, btVector3 *larg9, btVector3 *larg10) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btRigidBody *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btRigidBody *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  int arg8 ;
  btVector3 *arg9 = 0 ;
  btVector3 *arg10 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    result = (btScalar)(arg1)->solveLinearAxis(arg2,arg3,*arg4,(btVector3 const &)*arg5,*arg6,(btVector3 const &)*arg7,arg8,(btVector3 const &)*arg9,(btVector3 const &)*arg10);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btTranslationalLimitMotor (btTranslationalLimitMotor *larg1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_set (btGeneric6DofConstraint *larg1, int larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_useSolveConstraintObsolete = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_get (btGeneric6DofConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_useSolveConstraintObsolete);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btGeneric6DofConstraint * lresult = (btGeneric6DofConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btGeneric6DofConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofConstraint *)0;
  }
}


EXPORT btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btGeneric6DofConstraint * lresult = (btGeneric6DofConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btGeneric6DofConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofConstraint *)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_0 (btGeneric6DofConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->calculateTransforms((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_1 (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->calculateTransforms();
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformA (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformB (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_0 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_0 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_1 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_1 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_buildJacobian (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo1 (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo1NonVirtual (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo2 (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo2NonVirtual (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_updateRHS (btGeneric6DofConstraint *larg1, btScalar larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btGeneric6DofConstraint_getAxis (btGeneric6DofConstraint *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btGeneric6DofConstraint const *)arg1)->getAxis(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getAngle (btGeneric6DofConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getAngle(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getRelativePivotPosition (btGeneric6DofConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getRelativePivotPosition(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setFrames (btGeneric6DofConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_testAngularLimitMotor (btGeneric6DofConstraint *larg1, int larg2) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->testAngularLimitMotor(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setLinearLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearLowerLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getLinearLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getLinearLowerLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setLinearUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearUpperLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getLinearUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getLinearUpperLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setAngularLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularLowerLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getAngularLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getAngularLowerLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setAngularUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularUpperLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getAngularUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getAngularUpperLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRotationalLimitMotor *_wrap_btGeneric6DofConstraint_getRotationalLimitMotor (btGeneric6DofConstraint *larg1, int larg2) {
  btRotationalLimitMotor * lresult = (btRotationalLimitMotor *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btRotationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btRotationalLimitMotor *)(arg1)->getRotationalLimitMotor(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRotationalLimitMotor *)0;
  }
}


EXPORT btTranslationalLimitMotor *_wrap_btGeneric6DofConstraint_getTranslationalLimitMotor (btGeneric6DofConstraint *larg1) {
  btTranslationalLimitMotor * lresult = (btTranslationalLimitMotor *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTranslationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTranslationalLimitMotor *)(arg1)->getTranslationalLimitMotor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTranslationalLimitMotor *)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setLimit (btGeneric6DofConstraint *larg1, int larg2, btScalar larg3, btScalar larg4) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setLimit(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_isLimited (btGeneric6DofConstraint *larg1, int larg2) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->isLimited(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_calcAnchorPos (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->calcAnchorPos();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_0 (btGeneric6DofConstraint *larg1, btRotationalLimitMotor *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8, btTypedConstraint::btConstraintInfo2 *larg9, int larg10, btVector3 *larg11, int larg12, int larg13) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int arg13 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = larg12;
  arg13 = larg13;
  try {
    result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12,arg13);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_1 (btGeneric6DofConstraint *larg1, btRotationalLimitMotor *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8, btTypedConstraint::btConstraintInfo2 *larg9, int larg10, btVector3 *larg11, int larg12) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = larg12;
  try {
    result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_getUseFrameOffset (btGeneric6DofConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseFrameOffset();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setUseFrameOffset (btGeneric6DofConstraint *larg1, int larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setUseFrameOffset(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setParam__SWIG_0 (btGeneric6DofConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setParam__SWIG_1 (btGeneric6DofConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getParam__SWIG_0 (btGeneric6DofConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getParam__SWIG_1 (btGeneric6DofConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setAxis (btGeneric6DofConstraint *larg1, btVector3 *larg2, btVector3 *larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_calculateSerializeBufferSize (btGeneric6DofConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btGeneric6DofConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btGeneric6DofConstraint_serialize (btGeneric6DofConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btGeneric6DofConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btGeneric6DofConstraint (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSliderConstraint *_wrap_new_btSliderConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btSliderConstraint * lresult = (btSliderConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btSliderConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btSliderConstraint *)new btSliderConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSliderConstraint *)0;
  }
}


EXPORT btSliderConstraint *_wrap_new_btSliderConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btSliderConstraint * lresult = (btSliderConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btSliderConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btSliderConstraint *)new btSliderConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSliderConstraint *)0;
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo1 (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo1NonVirtual (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo2 (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo2NonVirtual (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btScalar larg7, btScalar larg8) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btScalar arg7 ;
  btScalar arg8 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7,arg8);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btSliderConstraint_getRigidBodyA (btSliderConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btSliderConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btSliderConstraint_getRigidBodyB (btSliderConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btSliderConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getCalculatedTransformA (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getCalculatedTransformA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getCalculatedTransformB (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getCalculatedTransformB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetA__SWIG_0 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetB__SWIG_0 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetA__SWIG_1 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetB__SWIG_1 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLowerLinLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLowerLinLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setLowerLinLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLowerLinLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getUpperLinLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getUpperLinLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setUpperLinLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUpperLinLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLowerAngLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLowerAngLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setLowerAngLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLowerAngLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getUpperAngLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getUpperAngLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setUpperAngLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUpperAngLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSliderConstraint_getUseLinearReferenceFrameA (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseLinearReferenceFrameA();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessDirLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessDirLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionDirLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionDirLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingDirLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingDirLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessDirAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessDirAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionDirAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionDirAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingDirAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingDirAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessLimLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessLimLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionLimLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionLimLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingLimLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingLimLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessLimAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessLimAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionLimAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionLimAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingLimAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingLimAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessOrthoLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessOrthoLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionOrthoLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionOrthoLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingOrthoLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingOrthoLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessOrthoAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessOrthoAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionOrthoAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionOrthoAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingOrthoAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingOrthoAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessDirLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessDirLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionDirLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionDirLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingDirLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingDirLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessDirAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessDirAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionDirAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionDirAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingDirAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingDirAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessLimLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessLimLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionLimLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionLimLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingLimLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingLimLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessLimAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessLimAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionLimAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionLimAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingLimAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingLimAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessOrthoLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessOrthoLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionOrthoLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionOrthoLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingOrthoLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingOrthoLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessOrthoAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessOrthoAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionOrthoAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionOrthoAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingOrthoAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingOrthoAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setPoweredLinMotor (btSliderConstraint *larg1, int larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setPoweredLinMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSliderConstraint_getPoweredLinMotor (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getPoweredLinMotor();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setTargetLinMotorVelocity (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTargetLinMotorVelocity(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getTargetLinMotorVelocity (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTargetLinMotorVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setMaxLinMotorForce (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxLinMotorForce(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getMaxLinMotorForce (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMaxLinMotorForce();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setPoweredAngMotor (btSliderConstraint *larg1, int larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setPoweredAngMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSliderConstraint_getPoweredAngMotor (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getPoweredAngMotor();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setTargetAngMotorVelocity (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTargetAngMotorVelocity(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getTargetAngMotorVelocity (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTargetAngMotorVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setMaxAngMotorForce (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxAngMotorForce(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getMaxAngMotorForce (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMaxAngMotorForce();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLinearPos (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getLinearPos();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getAngularPos (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getAngularPos();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSliderConstraint_getSolveLinLimit (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getSolveLinLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLinDepth (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLinDepth();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSliderConstraint_getSolveAngLimit (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getSolveAngLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getAngDepth (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngDepth();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_calculateTransforms (btSliderConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->calculateTransforms((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_testLinLimits (btSliderConstraint *larg1) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->testLinLimits();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_testAngLimits (btSliderConstraint *larg1) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->testAngLimits();
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSliderConstraint_getAncorInA (btSliderConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = (arg1)->getAncorInA();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btSliderConstraint_getAncorInB (btSliderConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = (arg1)->getAncorInB();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btSliderConstraint_getUseFrameOffset (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseFrameOffset();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setUseFrameOffset (btSliderConstraint *larg1, int larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setUseFrameOffset(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setFrames (btSliderConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setParam__SWIG_0 (btSliderConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setParam__SWIG_1 (btSliderConstraint *larg1, int larg2, btScalar larg3) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getParam__SWIG_0 (btSliderConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getParam__SWIG_1 (btSliderConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSliderConstraint_calculateSerializeBufferSize (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSliderConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btSliderConstraint_serialize (btSliderConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btSliderConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btSliderConstraint (btSliderConstraint *larg1) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btGeneric6DofSpringConstraint *_wrap_new_btGeneric6DofSpringConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btGeneric6DofSpringConstraint * lresult = (btGeneric6DofSpringConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btGeneric6DofSpringConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btGeneric6DofSpringConstraint *)new btGeneric6DofSpringConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofSpringConstraint *)0;
  }
}


EXPORT btGeneric6DofSpringConstraint *_wrap_new_btGeneric6DofSpringConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btGeneric6DofSpringConstraint * lresult = (btGeneric6DofSpringConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btGeneric6DofSpringConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btGeneric6DofSpringConstraint *)new btGeneric6DofSpringConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofSpringConstraint *)0;
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_enableSpring (btGeneric6DofSpringConstraint *larg1, int larg2, int larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->enableSpring(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setStiffness (btGeneric6DofSpringConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setStiffness(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setDamping (btGeneric6DofSpringConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setDamping(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setEquilibriumPoint__SWIG_0 (btGeneric6DofSpringConstraint *larg1) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setEquilibriumPoint();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setEquilibriumPoint__SWIG_1 (btGeneric6DofSpringConstraint *larg1, int larg2) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setEquilibriumPoint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setEquilibriumPoint__SWIG_2 (btGeneric6DofSpringConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setEquilibriumPoint(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setAxis (btGeneric6DofSpringConstraint *larg1, btVector3 *larg2, btVector3 *larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_getInfo2 (btGeneric6DofSpringConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofSpringConstraint_calculateSerializeBufferSize (btGeneric6DofSpringConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btGeneric6DofSpringConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btGeneric6DofSpringConstraint_serialize (btGeneric6DofSpringConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btGeneric6DofSpringConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btGeneric6DofSpringConstraint (btGeneric6DofSpringConstraint *larg1) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btUniversalConstraint *_wrap_new_btUniversalConstraint (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5) {
  btUniversalConstraint * lresult = (btUniversalConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btUniversalConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btUniversalConstraint *)new btUniversalConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btUniversalConstraint *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAnchor (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAnchor2 (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAxis1 (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAxis2 (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btUniversalConstraint_getAngle1 (btUniversalConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btUniversalConstraint_getAngle2 (btUniversalConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btUniversalConstraint_setUpperLimit (btUniversalConstraint *larg1, btScalar larg2, btScalar larg3) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setUpperLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUniversalConstraint_setLowerLimit (btUniversalConstraint *larg1, btScalar larg2, btScalar larg3) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setLowerLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUniversalConstraint_setAxis (btUniversalConstraint *larg1, btVector3 *larg2, btVector3 *larg3) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btUniversalConstraint (btUniversalConstraint *larg1) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btHinge2Constraint *_wrap_new_btHinge2Constraint (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5) {
  btHinge2Constraint * lresult = (btHinge2Constraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btHinge2Constraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btHinge2Constraint *)new btHinge2Constraint(*arg1,*arg2,*arg3,*arg4,*arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHinge2Constraint *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAnchor (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAnchor2 (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAxis1 (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAxis2 (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btHinge2Constraint_getAngle1 (btHinge2Constraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHinge2Constraint_getAngle2 (btHinge2Constraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btHinge2Constraint_setUpperLimit (btHinge2Constraint *larg1, btScalar larg2) {
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUpperLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHinge2Constraint_setLowerLimit (btHinge2Constraint *larg1, btScalar larg2) {
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLowerLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btHinge2Constraint (btHinge2Constraint *larg1) {
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSequentialImpulseConstraintSolver *_wrap_new_btSequentialImpulseConstraintSolver () {
  btSequentialImpulseConstraintSolver * lresult = (btSequentialImpulseConstraintSolver *)0 ;
  btSequentialImpulseConstraintSolver *result = 0 ;
  
  try {
    result = (btSequentialImpulseConstraintSolver *)new btSequentialImpulseConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSequentialImpulseConstraintSolver *)0;
  }
}


EXPORT void _wrap_delete_btSequentialImpulseConstraintSolver (btSequentialImpulseConstraintSolver *larg1) {
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSequentialImpulseConstraintSolver_solveGroup (btSequentialImpulseConstraintSolver *larg1, btCollisionObject **larg2, int larg3, btPersistentManifold **larg4, int larg5, btTypedConstraint **larg6, int larg7, btContactSolverInfo *larg8, btIDebugDraw *larg9, btDispatcher *larg10) {
  btScalar lresult = (btScalar)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  btCollisionObject **arg2 = (btCollisionObject **) 0 ;
  int arg3 ;
  btPersistentManifold **arg4 = (btPersistentManifold **) 0 ;
  int arg5 ;
  btTypedConstraint **arg6 = (btTypedConstraint **) 0 ;
  int arg7 ;
  btContactSolverInfo *arg8 = 0 ;
  btIDebugDraw *arg9 = (btIDebugDraw *) 0 ;
  btDispatcher *arg10 = (btDispatcher *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    result = (btScalar)(arg1)->solveGroup(arg2,arg3,arg4,arg5,arg6,arg7,(btContactSolverInfo const &)*arg8,arg9,arg10);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSequentialImpulseConstraintSolver_reset (btSequentialImpulseConstraintSolver *larg1) {
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->reset();
    
  } catch (...) {
    
  }
}


EXPORT unsigned long _wrap_btSequentialImpulseConstraintSolver_btRand2 (btSequentialImpulseConstraintSolver *larg1) {
  unsigned long lresult = (unsigned long)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  unsigned long result;
  
  arg1 = larg1;
  try {
    result = (unsigned long)(arg1)->btRand2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned long)0;
  }
}


EXPORT int _wrap_btSequentialImpulseConstraintSolver_btRandInt2 (btSequentialImpulseConstraintSolver *larg1, int larg2) {
  int lresult = (int)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  int arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->btRandInt2(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSequentialImpulseConstraintSolver_setRandSeed (btSequentialImpulseConstraintSolver *larg1, unsigned long larg2) {
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  unsigned long arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRandSeed(arg2);
    
  } catch (...) {
    
  }
}


EXPORT unsigned long _wrap_btSequentialImpulseConstraintSolver_getRandSeed (btSequentialImpulseConstraintSolver *larg1) {
  unsigned long lresult = (unsigned long)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  unsigned long result;
  
  arg1 = larg1;
  try {
    result = (unsigned long)((btSequentialImpulseConstraintSolver const *)arg1)->getRandSeed();
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned long)0;
  }
}


EXPORT btConstraintSolverType _wrap_btSequentialImpulseConstraintSolver_getSolverType (btSequentialImpulseConstraintSolver *larg1) {
  btConstraintSolverType lresult = (btConstraintSolverType)0 ;
  btSequentialImpulseConstraintSolver *arg1 = (btSequentialImpulseConstraintSolver *) 0 ;
  btConstraintSolverType result;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolverType)((btSequentialImpulseConstraintSolver const *)arg1)->getSolverType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolverType)0;
  }
}


EXPORT btSoftRigidDynamicsWorld *_wrap_new_btSoftRigidDynamicsWorld__SWIG_0 (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4, btSoftBodySolver *larg5) {
  btSoftRigidDynamicsWorld * lresult = (btSoftRigidDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btSoftBodySolver *arg5 = (btSoftBodySolver *) 0 ;
  btSoftRigidDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btSoftRigidDynamicsWorld *)new btSoftRigidDynamicsWorld(arg1,arg2,arg3,arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftRigidDynamicsWorld *)0;
  }
}


EXPORT btSoftRigidDynamicsWorld *_wrap_new_btSoftRigidDynamicsWorld__SWIG_1 (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4) {
  btSoftRigidDynamicsWorld * lresult = (btSoftRigidDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btSoftRigidDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btSoftRigidDynamicsWorld *)new btSoftRigidDynamicsWorld(arg1,arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftRigidDynamicsWorld *)0;
  }
}


EXPORT void _wrap_delete_btSoftRigidDynamicsWorld (btSoftRigidDynamicsWorld *larg1) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_debugDrawWorld (btSoftRigidDynamicsWorld *larg1) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_addSoftBody__SWIG_0 (btSoftRigidDynamicsWorld *larg1, btSoftBody *larg2, short larg3, short larg4) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addSoftBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_addSoftBody__SWIG_1 (btSoftRigidDynamicsWorld *larg1, btSoftBody *larg2, short larg3) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  short arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addSoftBody(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_addSoftBody__SWIG_2 (btSoftRigidDynamicsWorld *larg1, btSoftBody *larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addSoftBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_removeSoftBody (btSoftRigidDynamicsWorld *larg1, btSoftBody *larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeSoftBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_removeCollisionObject (btSoftRigidDynamicsWorld *larg1, btCollisionObject *larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftRigidDynamicsWorld_getDrawFlags (btSoftRigidDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSoftRigidDynamicsWorld const *)arg1)->getDrawFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_setDrawFlags (btSoftRigidDynamicsWorld *larg1, int larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDrawFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btSoftBodyWorldInfo *_wrap_btSoftRigidDynamicsWorld_getWorldInfo__SWIG_0 (btSoftRigidDynamicsWorld *larg1) {
  btSoftBodyWorldInfo * lresult = (btSoftBodyWorldInfo *)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBodyWorldInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyWorldInfo *) &(arg1)->getWorldInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyWorldInfo *)0;
  }
}


EXPORT btSoftBodyWorldInfo *_wrap_btSoftRigidDynamicsWorld_getWorldInfo__SWIG_1 (btSoftRigidDynamicsWorld *larg1) {
  btSoftBodyWorldInfo * lresult = (btSoftBodyWorldInfo *)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBodyWorldInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyWorldInfo *) &((btSoftRigidDynamicsWorld const *)arg1)->getWorldInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyWorldInfo *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btSoftRigidDynamicsWorld_getWorldType (btSoftRigidDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btSoftRigidDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT btSoftBodyArray *_wrap_btSoftRigidDynamicsWorld_getSoftBodyArray__SWIG_0 (btSoftRigidDynamicsWorld *larg1) {
  btSoftBodyArray * lresult = (btSoftBodyArray *)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBodyArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyArray *) &(arg1)->getSoftBodyArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyArray *)0;
  }
}


EXPORT btSoftBodyArray *_wrap_btSoftRigidDynamicsWorld_getSoftBodyArray__SWIG_1 (btSoftRigidDynamicsWorld *larg1) {
  btSoftBodyArray * lresult = (btSoftBodyArray *)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBodyArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyArray *) &((btSoftRigidDynamicsWorld const *)arg1)->getSoftBodyArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyArray *)0;
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_rayTest (btSoftRigidDynamicsWorld *larg1, btVector3 *larg2, btVector3 *larg3, btCollisionWorld::RayResultCallback *larg4) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btSoftRigidDynamicsWorld const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_rayTestSingle (btTransform *larg1, btTransform *larg2, btCollisionObject *larg3, btCollisionShape *larg4, btTransform *larg5, btCollisionWorld::RayResultCallback *larg6) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  btTransform *arg5 = 0 ;
  btCollisionWorld::RayResultCallback *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    btSoftRigidDynamicsWorld::rayTestSingle((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,(btCollisionShape const *)arg4,(btTransform const &)*arg5,*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_serialize (btSoftRigidDynamicsWorld *larg1, btSerializer *larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serialize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btSoftBodyRigidBodyCollisionConfiguration *_wrap_new_btSoftBodyRigidBodyCollisionConfiguration__SWIG_0 (btDefaultCollisionConstructionInfo *larg1) {
  btSoftBodyRigidBodyCollisionConfiguration * lresult = (btSoftBodyRigidBodyCollisionConfiguration *)0 ;
  btDefaultCollisionConstructionInfo *arg1 = 0 ;
  btSoftBodyRigidBodyCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyRigidBodyCollisionConfiguration *)new btSoftBodyRigidBodyCollisionConfiguration((btDefaultCollisionConstructionInfo const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyRigidBodyCollisionConfiguration *)0;
  }
}


EXPORT btSoftBodyRigidBodyCollisionConfiguration *_wrap_new_btSoftBodyRigidBodyCollisionConfiguration__SWIG_1 () {
  btSoftBodyRigidBodyCollisionConfiguration * lresult = (btSoftBodyRigidBodyCollisionConfiguration *)0 ;
  btSoftBodyRigidBodyCollisionConfiguration *result = 0 ;
  
  try {
    result = (btSoftBodyRigidBodyCollisionConfiguration *)new btSoftBodyRigidBodyCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyRigidBodyCollisionConfiguration *)0;
  }
}


EXPORT void _wrap_delete_btSoftBodyRigidBodyCollisionConfiguration (btSoftBodyRigidBodyCollisionConfiguration *larg1) {
  btSoftBodyRigidBodyCollisionConfiguration *arg1 = (btSoftBodyRigidBodyCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCollisionAlgorithmCreateFunc *_wrap_btSoftBodyRigidBodyCollisionConfiguration_getCollisionAlgorithmCreateFunc (btSoftBodyRigidBodyCollisionConfiguration *larg1, int larg2, int larg3) {
  btCollisionAlgorithmCreateFunc * lresult = (btCollisionAlgorithmCreateFunc *)0 ;
  btSoftBodyRigidBodyCollisionConfiguration *arg1 = (btSoftBodyRigidBodyCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithmCreateFunc *)(arg1)->getCollisionAlgorithmCreateFunc(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithmCreateFunc *)0;
  }
}



const btVector3& btSoftBodyGetNodePosition(const btSoftBody *body, int n) {
	return body->m_nodes[n].m_x;
}

void btSoftBodySetNodePosition(btSoftBody *body, int n, const btVector3& pos) {
	body->m_nodes[n].m_x = pos;
}

void btSoftBodySetStretch(btSoftBody *body, float val) {
	body->m_materials[0]->m_kLST = val;
}

void btSoftBodySetShear(btSoftBody *body, float val) {
	body->m_materials[0]->m_kAST = val;
}

EXPORT btVector3 *_wrap_btSoftBodyGetNodePosition (btSoftBody *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &btSoftBodyGetNodePosition((btSoftBody const *)arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSoftBodySetNodePosition (btSoftBody *larg1, int larg2, btVector3 *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBodySetNodePosition(arg1,arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySetStretch (btSoftBody *larg1, float larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  float arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSoftBodySetStretch(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySetShear (btSoftBody *larg1, float larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  float arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSoftBodySetShear(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSparseSdf3_cells_set (btSparseSdf< 3 > *larg1, btAlignedObjectArray< btSparseSdf< 3 >::Cell * > *larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  btAlignedObjectArray< btSparseSdf< 3 >::Cell * > *arg2 = (btAlignedObjectArray< btSparseSdf< 3 >::Cell * > *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->cells = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btAlignedObjectArray< btSparseSdf< 3 >::Cell * > *_wrap_btSparseSdf3_cells_get (btSparseSdf< 3 > *larg1) {
  btAlignedObjectArray< btSparseSdf< 3 >::Cell * > * lresult = (btAlignedObjectArray< btSparseSdf< 3 >::Cell * > *)0 ;
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  btAlignedObjectArray< btSparseSdf< 3 >::Cell * > *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btAlignedObjectArray< btSparseSdf< 3 >::Cell * > *)& ((arg1)->cells);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAlignedObjectArray< btSparseSdf< 3 >::Cell * > *)0;
  }
}


EXPORT void _wrap_btSparseSdf3_voxelsz_set (btSparseSdf< 3 > *larg1, btScalar larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->voxelsz = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSparseSdf3_voxelsz_get (btSparseSdf< 3 > *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->voxelsz);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSparseSdf3_puid_set (btSparseSdf< 3 > *larg1, int larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->puid = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSparseSdf3_puid_get (btSparseSdf< 3 > *larg1) {
  int lresult = (int)0 ;
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->puid);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSparseSdf3_ncells_set (btSparseSdf< 3 > *larg1, int larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->ncells = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSparseSdf3_ncells_get (btSparseSdf< 3 > *larg1) {
  int lresult = (int)0 ;
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->ncells);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSparseSdf3_m_clampCells_set (btSparseSdf< 3 > *larg1, int larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_clampCells = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSparseSdf3_m_clampCells_get (btSparseSdf< 3 > *larg1) {
  int lresult = (int)0 ;
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_clampCells);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSparseSdf3_nprobes_set (btSparseSdf< 3 > *larg1, int larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->nprobes = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSparseSdf3_nprobes_get (btSparseSdf< 3 > *larg1) {
  int lresult = (int)0 ;
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->nprobes);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSparseSdf3_nqueries_set (btSparseSdf< 3 > *larg1, int larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->nqueries = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSparseSdf3_nqueries_get (btSparseSdf< 3 > *larg1) {
  int lresult = (int)0 ;
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->nqueries);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSparseSdf3_Initialize__SWIG_0 (btSparseSdf< 3 > *larg1, int larg2, int larg3) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->Initialize(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSparseSdf3_Initialize__SWIG_1 (btSparseSdf< 3 > *larg1, int larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->Initialize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSparseSdf3_Initialize__SWIG_2 (btSparseSdf< 3 > *larg1) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->Initialize();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSparseSdf3_Reset (btSparseSdf< 3 > *larg1) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->Reset();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSparseSdf3_GarbageCollect__SWIG_0 (btSparseSdf< 3 > *larg1, int larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->GarbageCollect(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSparseSdf3_GarbageCollect__SWIG_1 (btSparseSdf< 3 > *larg1) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->GarbageCollect();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSparseSdf3_RemoveReferences (btSparseSdf< 3 > *larg1, btCollisionShape *larg2) {
  int lresult = (int)0 ;
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->RemoveReferences(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSparseSdf3_Evaluate (btSparseSdf< 3 > *larg1, btVector3 *larg2, btCollisionShape *larg3, btVector3 *larg4, btScalar larg5) {
  btScalar lresult = (btScalar)0 ;
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  btVector3 *arg2 = 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btScalar)(arg1)->Evaluate((btVector3 const &)*arg2,(btCollisionShape const *)arg3,*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSparseSdf3_BuildCell (btSparseSdf< 3 > *larg1, btSparseSdf< 3 >::Cell *larg2) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  btSparseSdf< 3 >::Cell *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->BuildCell(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSparseSdf3_DistanceToShape (btVector3 *larg1, btCollisionShape *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btSparseSdf< 3 >::SWIGTEMPLATEDISAMBIGUATOR DistanceToShape((btVector3 const &)*arg1,(btCollisionShape const *)arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btSparseSdf< 3 >::IntFrac *_wrap_btSparseSdf3_Decompose (btScalar larg1) {
  btSparseSdf< 3 >::IntFrac * lresult = (btSparseSdf< 3 >::IntFrac *)0 ;
  btScalar arg1 ;
  btSparseSdf< 3 >::IntFrac result;
  
  arg1 = larg1;
  try {
    result = btSparseSdf< 3 >::SWIGTEMPLATEDISAMBIGUATOR Decompose(arg1);
    lresult = new btSparseSdf< 3 >::IntFrac(result);
    return lresult;
  } catch (...) {
    return (btSparseSdf< 3 >::IntFrac *)0;
  }
}


EXPORT btScalar _wrap_btSparseSdf3_Lerp (btScalar larg1, btScalar larg2, btScalar larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btSparseSdf< 3 >::SWIGTEMPLATEDISAMBIGUATOR Lerp(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT unsigned int _wrap_btSparseSdf3_Hash (int larg1, int larg2, int larg3, btCollisionShape *larg4) {
  unsigned int lresult = (unsigned int)0 ;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  unsigned int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (unsigned int)btSparseSdf< 3 >::SWIGTEMPLATEDISAMBIGUATOR Hash(arg1,arg2,arg3,(btCollisionShape const *)arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT btSparseSdf< 3 > *_wrap_new_btSparseSdf3 () {
  btSparseSdf< 3 > * lresult = (btSparseSdf< 3 > *)0 ;
  btSparseSdf< 3 > *result = 0 ;
  
  try {
    result = (btSparseSdf< 3 > *)new btSparseSdf< 3 >();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSparseSdf< 3 > *)0;
  }
}


EXPORT void _wrap_delete_btSparseSdf3 (btSparseSdf< 3 > *larg1) {
  btSparseSdf< 3 > *arg1 = (btSparseSdf< 3 > *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}



typedef float floatArray;


typedef btVector3 btVector3Array;

